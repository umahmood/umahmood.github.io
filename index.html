<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  

  <title> Usman Mahmood </title>

  
  <link rel="stylesheet" href="https://fallthrough.io/css/poole.css">
  <link rel="stylesheet" href="https://fallthrough.io/css/syntax.css">
  <link rel="stylesheet" href="https://fallthrough.io/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link href="https://fallthrough.io/index.xml" rel="alternate" type="application/rss+xml" title="Usman Mahmood" />

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

  <link href='http://fonts.googleapis.com/css?family=Raleway:400,300' rel='stylesheet' type='text/css'>

  <script src="//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: ['Raleway']
      }
    });
  </script>

</head>

<body>

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 style="font-size: 60px" class="brand"><a href="https://fallthrough.io">Usman Mahmood</a></h1><br/>
      <p class="lead">
       Algorithms &#43; Data Structures = Programs 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://fallthrough.io/blog">Posts</a></li>
      
        <li><a href="/about/">About </a></li>
      
      <li><a href="https://github.com/umahmood">Github</a></li>
      <br/>
     
      <a href="https://github.com/umahmood"><i class="fa fa-github-square"></i></a>&nbsp;&nbsp;
    
    <br/><br/>
    &copy; 2015 Usman Mahmood. All rights reserved.</p>
    
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/08/golang-uk-conf-2015/">
        Golang UK Conference 2015
      </a>
    </h1>

    <span class="post-date">Aug 25, 2015</span>

    


    

<p><img src="https://i.imgur.com/LJfFYSS.png" alt="British Gopher" /></p>

<p>On Friday the 21st of August I attended the <a href="http://www.golanguk.com/">Golang UK conference 2015</a> held at
the amazing Brewery in London. This post is a short write up of my time at the
conference.</p>

<p>This was my first ever conference so apart from the talks, I did not know what
else to expect. Overall though, I found the conference was excellent and I met
a wide range of interesting people.</p>

<h5 id="turnout:95f078b9982a0bb9d2c4f8afc300946a">Turnout</h5>

<p>The turnout was quite big with over 250 delegates from all over the world.</p>

<h5 id="go-usage:95f078b9982a0bb9d2c4f8afc300946a">Go usage</h5>

<p>From the people I met no one was really using Go in a big way, but had an
API or a small server component written in Go. However, everyone was expecting
to increase there Go usage through out the coming year.</p>

<h5 id="talks:95f078b9982a0bb9d2c4f8afc300946a">Talks</h5>

<p>The conference consisted of 2 tracks, a main track and a side track. The talks I
went to:</p>

<ul>
<li>Opening Keynote</li>
<li>Crossing the Language Chasm</li>
<li>Building API&rsquo;s</li>
<li>Complex Concurrency Patterns in Go</li>
<li>Code Analysis</li>
<li>Understanding Memory Allocation</li>
<li>Whispered Secrets</li>
<li>The Go Community</li>
</ul>

<p>Out of all the talks, the best one was Code Analysis presented by Francesc Campoy.</p>

<h5 id="food:95f078b9982a0bb9d2c4f8afc300946a">Food :)</h5>

<p>The food served at the conference was absoutetly amazing. Many of the delgates
said that it was best food of any conference they had been to.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/08/gofmt-rewrite-rules/">
        Gofmt and Rewrite Rules
      </a>
    </h1>

    <span class="post-date">Aug 4, 2015</span>

    


    <p>One thing I absolutely love about Go is its tooling support. Whenever I use the
numerous tools I always discover something new. In this short post I will be
showing off gofmt&rsquo;s -r flag, this flag allows you to apply a rewrite rule to your
source before formatting.</p>

<p>A rewrite rule is a string in the following format:</p>

<pre><code>pattern -&gt; replacement
</code></pre>

<p>Both pattern and replacement must be valid Go expressions (more on this later), lets
apply a simple rewrite to the following code:</p>

<pre><code>// test1.go
package main

import (
    &quot;fmt&quot;
)

func main() {
    foo := &quot;Hello World&quot;

    fmt.Println(foo)
}
</code></pre>

<p>The following rewrite rule changes the variable name from &lsquo;foo&rsquo; to &lsquo;bar&rsquo;:</p>

<pre><code>$ gofmt -r='foo -&gt; bar' test1.go
</code></pre>

<p>Output:</p>

<pre><code>// test1.go
package main

import (
    &quot;fmt&quot;
)

func main() {
    bar := &quot;Hello World&quot;

    fmt.Println(bar)
}
</code></pre>

<p>We will now apply a more powerful rule to the below code:</p>

<pre><code>// test2.go
package main

func main() {
    vals := make([]int, 0)

    vals = append(vals, 15)
    vals = append(vals, 17)
    vals = append(vals, 23)

    slice := vals[1:len(vals)]

    _ = slice
}
</code></pre>

<p>The line:</p>

<pre><code>slice := vals[1:len(vals)]
</code></pre>

<p>Is not very idiomatic Go so lets change this:</p>

<pre><code>$ gofmt -r='a[b:len(a)] -&gt; a[b:]' test2.go
</code></pre>

<p>Output:</p>

<pre><code>// test2.go
package main

func main() {
    vals := make([]int, 0)

    vals = append(vals, 15)
    vals = append(vals, 17)
    vals = append(vals, 23)

    slice := vals[1:]

    _ = slice
}
</code></pre>

<p>As you can see the code was correctly transformed. Notice how the rule used the
characters &lsquo;a&rsquo; and &lsquo;b&rsquo;. If your rule uses single-character lowercase identifiers,
then these will serve as wild-cards matching arbitrary sub-expressions; these
expressions will be substituted for the same identifiers in the replacement. So
the rule:</p>

<pre><code>-r='a[b:len(a)] -&gt; a[b:]'
</code></pre>

<p>Would match:</p>

<pre><code>x := vals[1:len(vals)] // vals[1:]
y := nums[5:len(nums)] // nums[5:]
</code></pre>

<p>Were on the first match:</p>

<p>&lsquo;a&rsquo; would be substituted for &lsquo;val&rsquo; <br/>
&lsquo;b&rsquo; would be substituted for &lsquo;1&rsquo; <br/></p>

<p>And on the second match:</p>

<p>&lsquo;a&rsquo; would be substituted for &lsquo;nums&rsquo; <br/>
&lsquo;b&rsquo; would be substituted for &lsquo;5&rsquo; <br/></p>

<p>An important thing to remember when using the -r flag is that the resulting
transformation must be a syntactically valid declaration list, statement list,
or expression. So the following rule:</p>

<pre><code>-r='a[b:len(a)] -&gt; a[const]'
</code></pre>

<p>Would be syntactically incorrect (const is a reserved keyword), and you would get
the error:</p>

<pre><code>parsing replacement a[const] at 1:4: expected operand, found 'const' 
</code></pre>

<p>If you would like to learn more about rewrite rules then run:</p>

<pre><code>$ godoc gofmt
</code></pre>

<p><strong>Note</strong>: godoc gofmt reports the following at the end:</p>

<pre><code>BUGS

The implementation of -r is a bit slow.
</code></pre>

<p>:)</p>

<p><strong>Note</strong>: I am using Go version 1.4.2</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/07/go-string-concat/">
        Go and String Concatenation
      </a>
    </h1>

    <span class="post-date">Jul 26, 2015</span>

    


    

<p>When writing Go code you should try to stay away from concatenating strings using the &lsquo;+&rsquo; and &lsquo;+=&rdquo; operators.</p>

<p>Strings in Go, like many other languages (Java, C#, etc&hellip;) are immutable, this means after a string has been created it is impossible to change. Here is what the <a href="https://golang.org/ref/spec#String_types">Go Programming Language Specification</a> has to say about the string type:</p>

<p><em>&ldquo;A string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is string.&rdquo;</em></p>

<p>Lets look at an example:</p>

<pre><code>var town string = &quot;Spring&quot;
town += &quot;field&quot;
</code></pre>

<p>When you write the above code the compiler actually creates a new sequence of bytes, and assigns it to the variable &lsquo;town&rsquo;. The string &ldquo;Spring&rdquo; is then eligible for garbage collection. Here is what the heap would look like, after the above code was run:</p>

<pre><code>           &quot;Spring&quot;

town ----&gt; &quot;Springfield&quot;
</code></pre>

<p>Now if we concatenate the string &lsquo;town&rsquo; with the another string:</p>

<pre><code>town = &quot;742 Evergreen Terrace &quot; + town
</code></pre>

<p>The heap would look like this:</p>

<pre><code>           &quot;Spring&quot;

           &quot;Springfield&quot;

town ----&gt; &quot;742 Evergreen Terrace Springfield&quot;
</code></pre>

<p>If you concatenate a lot of strings using &lsquo;+&rsquo; and &lsquo;+=&rsquo; you will be generating a lot of garbage. This will make the garbage collector work harder as all those potential dead strings will need to be analyzed and freed.</p>

<p>There are two ways to concatenate string more efficiently:</p>

<h5 id="1-strings-join:09d97f42a93e7b11514ce16c8075547b">1. strings.Join()</h5>

<pre><code>town := strings.Join([]string{&quot;Spring&quot;, &quot;field&quot;}, &quot;&quot;))
</code></pre>

<h5 id="2-bytes-buffer:09d97f42a93e7b11514ce16c8075547b">2. bytes.Buffer</h5>

<pre><code>func concat(vals ...string) string {
    var buffer bytes.Buffer
    for _, s := range vals {
        buffer.WriteString(s)
    }
    return buffer.String()
}

func main() {
    town := concat(&quot;Spring&quot;, &quot;field&quot;)

    names := []string{&quot;Homer&quot;, &quot;Moe&quot;, &quot;Barney&quot;, &quot;Carl&quot;, &quot;Lenny&quot;}

    friends := concat(names...)
    ...
}
</code></pre>

<p>You can use either, I prefer using the &lsquo;concat&rsquo; method as it&rsquo;s easier to read.</p>

<p>These two methods are much more efficient as behind the scenes they allocate a variable size buffer of bytes. Which can be modified over and over again with out leaving behind a lot of unused strings.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/07/calling-c-from-go/">
        Calling C from Go
      </a>
    </h1>

    <span class="post-date">Jul 25, 2015</span>

    


    

<p>This post will show you the basics of how to call C code from a Go package.</p>

<p>Lets get started with an example:</p>

<p>Create a header file &ldquo;add.h&rdquo; with a function prototype:</p>

<pre><code>#ifndef _ADD_H_
#define _ADD_H_
int add(int, int);
#endif
</code></pre>

<p>Create the source file &ldquo;add.c&rdquo; containing the definition for add:</p>

<pre><code>#include &quot;add.h&quot;

int add(int a, int b) 
{
   return a + b;
}
</code></pre>

<p>Create a Go package &ldquo;main.go&rdquo;:</p>

<pre><code>package main

// #include &quot;add.c&quot;
import &quot;C&quot;

import (
    &quot;fmt&quot;
)

func main() {
    r := C.add(40, 2)
    fmt.Println(&quot;result = &quot;, r)
}
</code></pre>

<p>Ouptut:</p>

<pre><code>$ go build main.go
$ ./main
result = 42
</code></pre>

<p>Notice the comment above the import &ldquo;C&rdquo; statement we include add.c not add.h.</p>

<p>If import &ldquo;C&rdquo; is immediately preceded by comments, then those comments become apart of the compilation process. If there are any spaces between the comments, then those are seen as normal go comments, for example:</p>

<pre><code>// #include &lt;math.h&gt;

// #include &lt;stdio.h&gt;
// #include &lt;errno.h&gt;
import &quot;C&quot;
</code></pre>

<p>The header files stdio.h and errno.h are included as part of the compilation process, math.h is <strong>not</strong>.</p>

<h2 id="inline-c:f1759daed9e47388fe7eae5373f5e76d">Inline C</h2>

<p>You can also write C code directly in the comments, here is an example:</p>

<pre><code>package main

/*
int fortytwo()
{
    return 42;
}
*/
import &quot;C&quot;

import (
    &quot;fmt&quot;
)

func main() {
    fmt.Println(C.fortytwo)     // address
    fmt.Println(C.fortytwo())   // invocation
}
</code></pre>

<p>Output:</p>

<pre><code>$ go build inline.go
$ ./inline
0x40014a0
42
</code></pre>

<h2 id="accessing-c-structs:f1759daed9e47388fe7eae5373f5e76d">Accessing C structs</h2>

<p>Assume we have the below C struct defined in a .h or .c file:</p>

<pre><code>struct point {
    int x;
    int y;
};
</code></pre>

<p>In order to access this from a Go package, you simple prefix the type name &ldquo;point&rdquo; with &ldquo;C.struct_&rdquo;:</p>

<pre><code>func main() {
    p := C.struct_point{}
    p.x = 99
    p.y = 42
    fmt.Printf(&quot;type:   %T\n&quot;, p)
    fmt.Printf(&quot;struct: %+v\n&quot;, p)
}
</code></pre>

<p>Output:</p>

<pre><code>$ go build cstruct.go
$ ./cstruct
type:   main._Ctype_struct_point
struct: {x:99 y:42}
</code></pre>

<h2 id="controlling-the-behaviour-of-the-c-compiler:f1759daed9e47388fe7eae5373f5e76d">Controlling the behaviour of the C compiler</h2>

<p>You can pass flags to the C compiler to control its behaviour. This is done by defining a CFLAGS with a pseudo #cgo directive in the comments. In the example below, the -H flag will be passed to the C compiler (clang in my case) when it&rsquo;s invoked. The -H flag tells clang to show the header includes and nesting depth.</p>

<pre><code>package main

// #cgo CFLAGS: -H
// #include &quot;add.c&quot;
import &quot;C&quot;

import (
    &quot;fmt&quot;
)

func main() {
    r := C.add(40, 2)
    fmt.Println(&quot;result = &quot;, r)
}
</code></pre>

<p>Ouptut:</p>

<pre><code>$ go build main.go
!! this output is from clang writing to stdout because we passed the -H flag !!
. ./add.c
.. ./add.h
. /usr/include/errno.h
.. /usr/include/sys/errno.h
... /usr/include/sys/cdefs.h
.... /usr/include/sys/_symbol_aliasing.h
.... /usr/include/sys/_posix_availability.h
...

$ ./main
result = 42
</code></pre>

<h2 id="peeking-behind-the-scenes:f1759daed9e47388fe7eae5373f5e76d">Peeking behind the scenes</h2>

<p>What is happening when we build a Go package that includes an import &ldquo;C&rdquo; statement.</p>

<p>Firstly import &ldquo;C&rdquo; is a pseudo-package it is not listed in the standard library. When the go compiler sees the pseudo-package import &ldquo;C&rdquo; it runs the <strong>cgo</strong> command, this generates all the supporting infrastructure. It transforms main.go outputting some .h and .c files, these are then passed to clang to compile.</p>

<p><strong>Note:</strong> the cgo command actually invokes the gcc compiler, however on my machine gcc is an alias for clang, so it&rsquo;s clang that is doing the compiling.</p>

<p>The output from the C compiler is an object file named _cgo_.o, which contains the compiled C code. This object code (_cgo_.o) is then linked into the rest of the go binary.</p>

<p>Lets runs the cgo command directly to get a better understanding:</p>

<pre><code>$ go tool cgo main.go
</code></pre>

<p>This command will output a directory called _obj:</p>

<pre><code>$ ls _obj/  

_cgo_.o
_cgo_defun.c
_cgo_export.c
_cgo_export.h
_cgo_flags
_cgo_gotypes.go
_cgo_main.c
main.cgo1.go
main.cgo2.c
</code></pre>

<p>As stated _cgo_.o contains the compiled C code, one interesting file to browse is main.cgo2.c:</p>

<pre><code>$ cat main.cgo2.c

#line 10 &quot;/go/src/samples/main.go&quot;

 #include &quot;add.c&quot;

// Usual nonsense: if x and y are not equal, the type will be invalid
// (have a negative array count) and an inscrutable error will come
// out of the compiler and hopefully mention &quot;name&quot;.
#define __cgo_compile_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];

// Check at compile time that the sizes we use match our expectations.
#define __cgo_size_assert(t, n) __cgo_compile_assert_eq(sizeof(t), n, _cgo_sizeof_##t##_is_not_##n)

__cgo_size_assert(char, 1)
__cgo_size_assert(short, 2)
__cgo_size_assert(int, 4)
typedef long long __cgo_long_long;
__cgo_size_assert(__cgo_long_long, 8)
__cgo_size_assert(float, 4)
__cgo_size_assert(double, 8)

extern char* _cgo_topofstack(void);

#include &lt;errno.h&gt;
#include &lt;string.h&gt;

void
_cgo_7474d4d504ba_Cfunc_add(void *v)
{
    struct {
        int p0;
        int p1;
        int r;
        char __pad12[4];
    } __attribute__((__packed__)) *a = v;
    char *stktop = _cgo_topofstack();
    __typeof__(a-&gt;r) r = add(a-&gt;p0, a-&gt;p1);
    a = (void*)((char*)a + (_cgo_topofstack() - stktop));
    a-&gt;r = r;
}
</code></pre>

<p>Take a while to browse the other files, they are quite interesting.</p>

<p>I hope you enjoyed this post.</p>

<p><strong>Note:</strong> I am on OSX 10.10.4 64 bit using go version 1.4.2 and clang version 602.0.53.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/07/first/">
        First Post
      </a>
    </h1>

    <span class="post-date">Jul 25, 2015</span>

    


    <p>This is my blog. There are many like it, but this one is mine.</p>

  </div>
  
  
  
  
</div>


  </body>
</html>
