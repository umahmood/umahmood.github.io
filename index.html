<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  

  <title> Usman Mahmood </title>

  
  <link rel="stylesheet" href="https://fallthrough.io/css/poole.css">
  <link rel="stylesheet" href="https://fallthrough.io/css/syntax.css">
  <link rel="stylesheet" href="https://fallthrough.io/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link href="https://fallthrough.io/index.xml" rel="alternate" type="application/rss+xml" title="Usman Mahmood" />

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

  <link href='http://fonts.googleapis.com/css?family=Raleway:400,300' rel='stylesheet' type='text/css'>

  <script src="//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: ['Raleway']
      }
    });
  </script>

</head>

<body>

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 style="font-size: 60px" class="brand"><a href="https://fallthrough.io">Usman Mahmood</a></h1><br/>
      <p class="lead">
       Algorithms &#43; Data Structures = Programs 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://fallthrough.io/blog">Posts</a></li>
      
        <li><a href="/about/">About </a></li>
      
      <br/>
      <li><a href="https://github.com/umahmood">Github</a></li>
      <li><a href="https://twitter.com/make_slice">Twitter</a></li>
      <li><a href="https://keybase.io/usman">Keybase</a></li>

    <br/>
    &copy; 2016 Usman Mahmood. All rights reserved.</p>
    
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/10/using-sub-tests-benchmarks/">
        Using Subtests and Sub-benchmarks in Go
      </a>
    </h1>

    <span class="post-date">Oct 22, 2016</span>

    


    

<p>In this post we will walk through an example of how to use the new subtests and sub-benchmarks functionality introduced in Go 1.7.</p>

<h4 id="subtests:ab65b34deed84f4e72ae56b7904d376a">Subtests</h4>

<p>One of the nifty features in Go is the ability to write table driven tests. For example, if we wanted to test the function:</p>

<pre><code class="language-go">func Double(n int) int {
    return n * 2
}
</code></pre>

<p>Then we could write a table driven test as follows:</p>

<pre><code class="language-go">func TestDouble(t *testing.T) {
	testCases := []struct {
		n    int
		want int
	}{
		{2, 4},
		{4, 10},
		{3, 6},
	}
	for _, tc := range testCases {
		got := Double(tc.n)
		if got != tc.want {
			t.Errorf(&quot;fail got %v want %v&quot;, got, tc.want)
		}
	}
}
</code></pre>

<p><strong>Note:</strong> The test case {4, 10} is present to make the test fail, 4 * 2 != 10 ðŸ˜ƒ.</p>

<p>If we run this test, we get the following output:</p>

<pre><code>$ go test -v
=== RUN   TestDouble
--- FAIL: TestDouble (0.00s)
        example_test.go:25: fail got 8 want 10
FAIL
exit status 1
FAIL    example    0.005s
</code></pre>

<p>The problem here is that we don&rsquo;t know which table test case failed. It would be better, if we could identify a table test case, and display its name in the output if it fails.</p>

<p>This is what subtests in GO 1.7 allow us to do. The <em>testing.T</em> type now has a <em>Run</em> method, were the first argument is a string (the name of the test). And the second argument is a function. Below we re-implement the above test, using the <em>Run</em> method:</p>

<pre><code class="language-go">func TestDouble(t *testing.T) {
	testCases := []struct {
		n    int
		want int
	}{
		{2, 4},
		{4, 10},
		{3, 6},
	}
	for _, tc := range testCases {
		t.Run(fmt.Sprintf(&quot;input_%d&quot;, tc.n), func(t *testing.T) {
			got := Double(tc.n)
			if got != tc.want {
				t.Errorf(&quot;fail got %v want %v&quot;, got, tc.want)
			}
		})
	}
}
</code></pre>

<p>A few things to note here are that one, we are setting the name of the test to the &lsquo;n&rsquo; value of the test case. So our tests are named &ldquo;input_2&rdquo;, &ldquo;input_3&rdquo; and &ldquo;input_4&rdquo;. And two, for the second parameter we are passing in a closure which has the same method signature as a normal test.</p>

<p>If we run this test, we get the following output:</p>

<pre><code>$ go test -v
=== RUN   TestDouble
=== RUN   TestDouble/input_2
=== RUN   TestDouble/input_3
=== RUN   TestDouble/input_4
--- FAIL: TestDouble (0.00s)
    --- PASS: TestDouble/input_2 (0.00s)
    --- PASS: TestDouble/input_3 (0.00s)
    --- FAIL: TestDouble/input_4 (0.00s)
        example_test.go:43: fail got 8 want 10
FAIL
exit status 1
FAIL    example    0.006s
</code></pre>

<p>This time we get a more detailed output, we can see that &ldquo;input_4&rdquo; was the failing test case from the table. And the pass/fail status of each individual table test case.</p>

<p>We can run a subset of our table tests, by matching the unique names set for them (the first parameter to the Run method), as follows:</p>

<pre><code>$ go test -v -run=&quot;TestZap/input_2&quot;
=== RUN   TestZap
=== RUN   TestZap/input_2
--- PASS: TestZap (0.00s)
    --- PASS: TestZap/input_2 (0.00s)
PASS
ok      example    0.008s
</code></pre>

<p>Running many tests, by matching the test names:</p>

<pre><code>$ go test -v -run=&quot;TestZap/input_[1-3]&quot;
=== RUN   TestZap
=== RUN   TestZap/input_2
=== RUN   TestZap/input_3
--- PASS: TestZap (0.00s)
    --- PASS: TestZap/input_2 (0.00s)
    --- PASS: TestZap/input_3 (0.00s)
PASS
ok      example    0.006s
</code></pre>

<p>Here <em>&ldquo;input[1-3]&rdquo;</em> matched _&ldquo;input<em>2&rdquo;</em> and _&ldquo;input<em>3&rdquo;</em> but not _&ldquo;input<em>4&rdquo;</em>.</p>

<h4 id="sub-benchmarks:ab65b34deed84f4e72ae56b7904d376a">Sub-benchmarks</h4>

<p>Unlike table driven testing there was no equal approach for benchmarking. But now in Go 1.7, we have the ability to create table driven benchmarks. Imagine we need to benchmark the following function:</p>

<pre><code class="language-go">func AppendStringN(s string, n int) {
	a := make([]string, 0)
	for i := 0; i &lt; n; i++ {
		a = append(a, s)
	}
}  
</code></pre>

<p>We can define a top-level benchmark function like this:</p>

<pre><code class="language-go">func BenchmarkAppendStringN(b *testing.B) {
	benchmarks := []struct {
		fruit string
		n     int
	}{
		{fruit: &quot;apple&quot;, n: 10},
		{fruit: &quot;pear&quot;, n: 20},
		{fruit: &quot;mango&quot;, n: 40},
		{fruit: &quot;berry&quot;, n: 60},
		{fruit: &quot;banana&quot;, n: 80},
		{fruit: &quot;orange&quot;, n: 100},
	}
	for _, bm := range benchmarks {
		b.Run(bm.fruit, func(b *testing.B) {
			for i := 0; i &lt; b.N; i++ {
				AppendStringN(bm.fruit, bm.n)
			}
		})
	}
}
</code></pre>

<p>The <em>Run</em> methods signature is the same as described above. But for the <em>testing.B</em> type, rather than the <em>testing.T</em> type. Our benchmark names are set to &ldquo;apple&rdquo;, &ldquo;pear&rdquo;, &ldquo;mango&rdquo;, etc&hellip;</p>

<p>If we run this benchmark, we get the following output:</p>

<pre><code>$ go test -v -run=&quot;xxx&quot; -bench=.
BenchmarkAppendStringN/apple-8           3000000               495 ns/op
BenchmarkAppendStringN/pear-8            2000000               713 ns/op
BenchmarkAppendStringN/mango-8           1000000              1101 ns/op
BenchmarkAppendStringN/berry-8           1000000              1156 ns/op
BenchmarkAppendStringN/banana-8          1000000              1803 ns/op
BenchmarkAppendStringN/orange-8          1000000              1153 ns/op
PASS
ok      example_test    9.428s
</code></pre>

<p>An important thing to note is that, each time <em>b.Run</em> is invoked it creates a separate benchmark. The outer benchmark function (BenchmarkAppendStringN) is only run once and it is not measured.</p>

<p>One last thing to mention is that, like subtests. You can run individual benchmarks by there set unique names. Below, we run just the &ldquo;berry&rdquo; benchmark:</p>

<pre><code>$ go test -v -run=&quot;xxx&quot; -bench=&quot;/berry&quot;
BenchmarkAppendStringN/berry-8           1000000              1143 ns/op
PASS
ok      subtestbench    1.165s
</code></pre>

<p>I hope you have found this blog post helpful.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/08/svg-sprites/">
        SVG Sprites
      </a>
    </h1>

    <span class="post-date">Aug 16, 2016</span>

    


    <p>Within an single SVG file we can define many sprites. This consists of merging all your SVG sprites into a single .svg image file. Every sprite is wrapped in a &lsquo;symbol&rsquo; tag, like this:</p>

<pre><code>&lt;svg class=&quot;character&quot; width=&quot;100pt&quot; height=&quot;100pt&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
    &lt;symbol id=&quot;circle-red&quot; viewBox=&quot;0 0 100 100&quot;&gt;    
      &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;3&quot; fill=&quot;red&quot; /&gt;
    &lt;/symbol&gt;
    &lt;symbol id=&quot;circle-black&quot; viewBox=&quot;0 0 100 100&quot;&gt;    
      &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;3&quot; /&gt;
    &lt;/symbol&gt;
&lt;/svg&gt;
</code></pre>

<p>We can then use HTML or CSS to pick out each part of the image:</p>

<pre><code>&lt;hmtl&gt;
  &lt;body&gt;
     &lt;svg class=&quot;c-red&quot; &gt;
            &lt;use xlink:href=&quot;test.svg#circle-red&quot;&gt;&lt;/use&gt;
        &lt;/svg&gt;
        &lt;svg class=&quot;c-black&quot; &gt;
            &lt;use xlink:href=&quot;test.svg#circle-black&quot;&gt;&lt;/use&gt;
        &lt;/svg&gt;        
  &lt;/body&gt;
&lt;/hmtl&gt;
</code></pre>

<p>We can animate the sprite with CSS:</p>

<pre><code>&lt;style type=&quot;text/css&quot;&gt;
    .c-black:hover {
        fill: #fe2fd0;
    }
&lt;style&gt;
</code></pre>

<p>If creating an SVG sprite file seems tedious or error prone. You can use a tool like <a href="https://github.com/w0rm/gulp-svgstore">gulp-svgstore</a> to automate the process. And generate a single SVG file from your individual sprite files.</p>

<p>One of the advantages of using SVG sprites are the improved page load times. One of the disadvantages of using SVG sprites, is that when linking the &lsquo;use&rsquo; tag to the &lsquo;symbol&rsquo; tag, the image gets injected into the <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM">Shadow DOM</a>. Meaning we lose some CSS capabilities, and cannot apply some styling to the SVG image.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/06/update_packages/">
        Updating Third Party Packages in Go
      </a>
    </h1>

    <span class="post-date">Jun 11, 2016</span>

    


    <p>Just a short post on how to update packages using <em>go get</em>.</p>

<p>To update all third party packages in your <em>GOPATH</em> use the following command:</p>

<blockquote>
<p>go get -u all</p>
</blockquote>

<p>To update a specific package, just provide the full package name to <em>go get</em>:</p>

<blockquote>
<p>go get -u github.com/gorilla/mux</p>
</blockquote>

<p>What about vendor-ed packages? These are updated in exactly the same way as above:</p>

<blockquote>
<p>go get -u my-project/vendor/megacorp/foo</p>
</blockquote>

<p>If you want more information about your <em>GOPATH</em>, run the command:</p>

<blockquote>
<p>go help gopath</p>
</blockquote>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/03/sort-stable/">
        sort.Sort &amp; sort.Stable
      </a>
    </h1>

    <span class="post-date">Mar 13, 2016</span>

    


    <p>Go 1.6 made improvements to the Sort function in the sort package. It was improved to make fewer calls to the Less and Swap methods. Here are some benchmarks showing the performance of sort.Sort in Go 1.5 vs 1.6:</p>

<pre><code>Sort []int with Go 1.5
BenchmarkSort_1-4       20000000              67.2 ns/op
BenchmarkSort_10-4      10000000               227 ns/op
BenchmarkSort_100-4       500000              3863 ns/op
BenchmarkSort_1000-4       30000             52189 ns/op

Sort []int with Go 1.6
BenchmarkSort_1-4       20000000              64.7 ns/op
BenchmarkSort_10-4      10000000               137 ns/op
BenchmarkSort_100-4       500000              2849 ns/op
BenchmarkSort_1000-4       30000             46949 ns/op
</code></pre>

<p><em>source: <a href="https://talks.golang.org/2016/state-of-go.slide#24">state of go</a></em></p>

<p>Sort does not use a stable sorting algorithm, it does not make any guarantees about the final order of equal values. A stable sort algorithm, is one in which items which have the same key stay in the same relative order during the sort. The sorting algorithms mergesort and radixsort are stable, were as quicksort, heapsort and shellsort are not stable. If this property is important to your application then you may want to use sort.Stable.</p>

<p><a href="https://golang.org/src/sort/sort.go?s=5443:5468#L211">sort.Sort</a> under the hood uses the quicksort algorithm, were as <a href="https://golang.org/src/sort/sort.go?s=10143:10170#L336">sort.Stable</a> uses insertion sort. Below is an example of Sort and Stable in action:</p>

<pre><code>type byLength []string

func (b byLength) Len() int           { return len(b) }
func (b byLength) Less(i, j int) bool { return len(b[i]) &lt; len(b[j]) }
func (b byLength) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }

func main() {
    values1 := []string{&quot;ball&quot;, &quot;hell&quot;, &quot;one&quot;, &quot;joke&quot;, &quot;fool&quot;, &quot;moon&quot;, &quot;two&quot;}
    sort.Sort(byLength(values1))
    fmt.Println(&quot;sort.Sort&quot;, values1)
    
    values2 := []string{&quot;ball&quot;, &quot;hell&quot;, &quot;one&quot;, &quot;joke&quot;, &quot;fool&quot;, &quot;moon&quot;, &quot;two&quot;}
    sort.Stable(byLength(values2))
    fmt.Println(&quot;sort.Stable&quot;, values2)
}
</code></pre>

<p>Output:</p>

<pre><code>sort.Sort   [two one hell joke fool moon ball]
sort.Stable [one two ball hell joke fool moon]
</code></pre>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/12/defer-statement/">
        The Defer Statement
      </a>
    </h1>

    <span class="post-date">Dec 14, 2015</span>

    


    

<p>The Go programming language has a defer statement that allows for a function call to be run just before the currently running function returns. Here is how the defer statement is explained in the language specification:</p>

<p><em>&ldquo;A &ldquo;defer&rdquo; statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.&rdquo;</em></p>

<p>Here is example usage of the defer statement:</p>

<pre><code class="language-go">func DoWork(f Foo) {
    defer f.CleanUp()
    f.DoTask()
}
</code></pre>

<p>The function call in the defer statement (CleanUp), happens just before the function &lsquo;DoWork&rsquo; exits. Below I have listed some properties of the defer statement:</p>

<h3 id="defer-d-functions-are-executed-in-lifo:c0ee3214aa0f030d3b7e9ff843504550">Defer&rsquo;d functions are executed in LIFO</h3>

<p>Given the following program:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func a() {
	defer fmt.Println(&quot;a0&quot;)
	defer fmt.Println(&quot;a1&quot;)
	b()
}	
	
func b() {
	defer fmt.Println(&quot;b&quot;)
	c()
}


func c() {
	defer fmt.Println(&quot;c&quot;)
}

func main() {
	a()
}
</code></pre>

<p>Here is what the defer&rsquo;d queue looks like:</p>

<p>Front : [ fmt.Println(&ldquo;c&rdquo;) ][ fmt.Println(&ldquo;b&rdquo;) ][ fmt.Println(&ldquo;a1&rdquo;) ][ fmt.Println(&ldquo;a0&rdquo;) ]</p>

<p>And the output:</p>

<pre><code class="language-text">c
b
a1
a0
</code></pre>

<h3 id="defer-d-functions-execute-even-if-the-function-panics:c0ee3214aa0f030d3b7e9ff843504550">Defer&rsquo;d functions execute even if the function panics</h3>

<p>In the following program the method &lsquo;Space&rsquo; panics, but the defer&rsquo;d function queued up still executes.</p>

<pre><code class="language-go">func Space() {
    defer fmt.Println(&quot;I'm a rocket ship on my way to Mars&quot;)
    panic(&quot;On a collision course&quot;)
}
</code></pre>

<p>Output:</p>

<pre><code class="language-text">I'm a rocket ship on my way to Mars
panic: On a collision course

goroutine 1 [running]:
main.Space()
	/tmp/sandbox062698335/main.go:46 +0x160
main.main()
	/tmp/sandbox062698335/main.go:51 +0x20
</code></pre>

<p>When a panic function executes, it begins to unwind the stack executing any defer statements as it goes.</p>

<h3 id="arguments-are-evaluated-when-the-defer-statement-is-encountered:c0ee3214aa0f030d3b7e9ff843504550">Arguments are evaluated when the defer statement is encountered</h3>

<p>Take the following example:</p>

<pre><code class="language-go">func Foo() {
    var x int
    defer fmt.Println(&quot;value of x =&quot;, x)
    x = x + 1
    fmt.Println(&quot;value of x =&quot;, x)
}
</code></pre>

<p>You may expect the program to output:</p>

<pre><code class="language-text">value of x = 1
value of x = 1
</code></pre>

<p>But instead the output is:</p>

<pre><code class="language-text">value of x = 1
value of x = 0  // defer'd function call output
</code></pre>

<p>The reason for this is before the defer&rsquo;d function was queued, it&rsquo;s arguments were evaluated and saved (x = 0). When the defer&rsquo;d function was executed, rather than seeing that x == 1, it instead output the value of x it saved previously. The defer section in the Go language specification states:</p>

<p><em>&ldquo;Each time a &ldquo;defer&rdquo; statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked.&rdquo;</em></p>

<p>If we would like to have the arguments evaluated when the defer executes, wrap the function in a closure:</p>

<pre><code class="language-go">func Foo() {
    var x int
    defer func() {
        fmt.Println(&quot;value of x =&quot;, x) 
    }
    x = x + 1
    fmt.Println(&quot;value of x =&quot;, x)
}
</code></pre>

<p>Output:</p>

<pre><code class="language-text">value of x = 1
value of x = 1
</code></pre>

<h3 id="defer-d-functions-can-access-named-parameters:c0ee3214aa0f030d3b7e9ff843504550">Defer&rsquo;d functions can access named parameters</h3>

<p>In the following example (taken from the defer section of the language specification):</p>

<pre><code class="language-go">// f returns 1
func f() (result int) {
	defer func() {
		result++
	}()
	return 0
}
</code></pre>

<p>You can see that defer&rsquo;d functions can access and modify named parameters. Notice how the defer in function f is a closure, otherwise we could not capture the most up to date value of &lsquo;result&rsquo; or modify it.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/12/channel-axioms/">
        Go Channel Axioms
      </a>
    </h1>

    <span class="post-date">Dec 14, 2015</span>

    


    

<p>A while ago I was watching a tech talk by Blake Caldwell on <a href="https://www.youtube.com/watch?v=PyBJQA4clfc">Building Resilient Services with Go</a>. In his presentation he had a slide which listed go channel axioms. I have listed his channel axioms here and provided some short code snippets to hopefully clarify them.</p>

<h3 id="a-send-to-a-nil-channel-blocks-forever:3c6d760ac1dd0a5b6f008ac700644390">A send to a nil channel blocks forever</h3>

<pre><code class="language-go">var ch chan bool
ch &lt;- true // will always block
</code></pre>

<p>We declare a channel &lsquo;ch&rsquo; but do not initialize it (with make), so it is a nil channel. We then attempt to <strong>send</strong> a value down the channel, this causes a blocking operation.</p>

<h3 id="a-receive-from-a-nil-channel-blocks-forever:3c6d760ac1dd0a5b6f008ac700644390">A receive from a nil channel blocks forever</h3>

<pre><code class="language-go">var ch chan bool
v := &lt;-ch // will always block
</code></pre>

<p>We declare a channel &lsquo;ch&rsquo; but do not initialize it (with make), so it is a nil channel, We then attempt to <strong>receive</strong> a value from the channel, this causes a blocking operation.</p>

<h3 id="a-send-to-a-closed-channel-panics:3c6d760ac1dd0a5b6f008ac700644390">A send to a closed channel panics</h3>

<pre><code class="language-go">ch := make(chan bool)
...
close(ch)
...
ch &lt;- true // panics!
</code></pre>

<p>We initialize a channel &lsquo;ch&rsquo; then later close the channel, and then later attempt to <strong>send</strong> a value down the channel. This causes a panic, and we receive a stack trace. In this case, before we send a value down the channel, we may want check if the channel is open:</p>

<pre><code class="language-go">if v, ok := &lt;-ch; ok {
    // ch is open
}
</code></pre>

<h3 id="a-receive-from-a-closed-channel-returns-the-zero-value-immediately:3c6d760ac1dd0a5b6f008ac700644390">A receive from a closed channel returns the zero value immediately</h3>

<pre><code class="language-go">ch := make(chan int)
...
close(ch)
...
v := &lt;-ch // v = 0
</code></pre>

<p>We initialize a channel &lsquo;ch&rsquo; then later close the channel, and then later attempt to <strong>receive</strong> a value from the channel. This causes the zero value to be returned immediately, this is a non-blocking operation.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/11/dotgo-eu-2015/">
        dotGo 2015
      </a>
    </h1>

    <span class="post-date">Nov 12, 2015</span>

    


    

<p><img src="https://i.imgur.com/uiLTeK2.png" alt="Dot conf. logo" /></p>

<p>On Monday the 9th of November I was in Paris attending dotGo, the European Go conference. This blog post is a summary of my time there.</p>

<h3 id="pre-conference:184802dcbae007fe12d15202c45527c5">Pre-Conference</h3>

<p>The day before the conference, the Paris tech talks group organized a pre-conference meetup/party. There were a large number of delegates who turned up and the meet up consisted of about six or seven talks. The talks were about how individuals at there respective companies were using Go. All the projects demoed and talked about were network related i.e. using Go to write a load balancer which solved a particular problem. After the talks, there was a chance to socialize and eat pizza with other gophers :).</p>

<h3 id="venue:184802dcbae007fe12d15202c45527c5">Venue</h3>

<p>On the day of the conference I made my way down to the venue ThÃ©Ã¢tre de Paris. This venue was absolutely beautiful, the high ceilings, the seating, the theatre boxes and stage. Made this venue truly great, and I was very grateful that the building owners allowed the conference to take place there.</p>

<h3 id="talks:184802dcbae007fe12d15202c45527c5">Talks</h3>

<p>dotGo is a single track conference which I prefer, as I always have a hard time making my mind up about which talks to attend. Here is a summary of the talks:</p>

<h4 id="microservices:184802dcbae007fe12d15202c45527c5">Microservices</h4>

<p>This talk was given by Peter Bourgon the creator of Gokit. The talk centered around his thoughts, opinions and efforts of getting people to adopt microservices in organizations.</p>

<p><a href="https://github.com/go-kit/kit">gokit on github</a></p>

<h4 id="tools-for-working-with-go-code:184802dcbae007fe12d15202c45527c5">Tools for working with Go code</h4>

<p>This talk was given by Fatih Arslan the creator of Vim-go. This was a great talk were you were introduced to a wide range of tools that exist in the Go ecosystem. Tools such as <em>gorename</em>, <em>generate</em> and <em>oracle</em> were presented along with examples on how to use them.</p>

<h4 id="the-docker-trail:184802dcbae007fe12d15202c45527c5">The Docker Trail</h4>

<p>This talk was given by Jessica Frazelle who is a core team member at Docker. She talked about three odd things the team at Docker noticed and how they went about debugging and fixing them.</p>

<h4 id="applied-concurrency-in-go:184802dcbae007fe12d15202c45527c5">Applied Concurrency in Go</h4>

<p>A talk given by Matt Aimonetti who is the co-founder and CTO of Splice. Matt was running Go code (which used concurrency) on an Arduino which made some LED&rsquo;s blink according to some rules. He ran various versions of the code all of which contained concurrency related bugs, he fixed the bugs as he went along. Showing all the the mistakes we usually make when writing concurrent code.</p>

<h4 id="functional-go:184802dcbae007fe12d15202c45527c5">Functional Go?</h4>

<p>A talk given by the excellent Francesc Campoy Flores a member of the Google Go team. This talk concentrated on his efforts to use Go in a functional manner, after his experiences with Haskell. The functional code he wrote for the problem he was trying solve was scary, he really was actively working against the language (something he admitted). It was a fun talk though.</p>

<h4 id="the-other-side-of-go-programming-pictures:184802dcbae007fe12d15202c45527c5">The Other Side of Go: Programming Pictures</h4>

<p>This talk was given by Anthony Starks the creator of SVGo. It was great to see what people were doing with Go outside the network related projects we always see. Anthony&rsquo;s talk was great, he was using Go to generate SVG for all sorts of things. One important point that stayed with me about his talk, was about dissecting a complex image into just lines and arcs, this allowed you to then build up a replica image (using SVGo) using just these primitives. He also spoke about his project with great passion.</p>

<h4 id="gomobile:184802dcbae007fe12d15202c45527c5">Gomobile</h4>

<p>David Crawshaw the creator of gomobile spoke about the challenges of getting Go up and running on mobile platforms. Some of the topics he discussed were Go&rsquo;s calling convention and threading (goroutines, OS threads and CPUs).</p>

<p><a href="https://github.com/golang/mobile">gombile on github</a></p>

<h4 id="a-tour-of-the-bleve:184802dcbae007fe12d15202c45527c5">A Tour of the Bleve</h4>

<p>Marty Schoch the creator of Bleve gave an excellent talk on the open-source full-text search library for Go. Marty presented great code examples along side his talk, which really helped clarify the points he was trying to get across. He also spoke about how members of the community have contributed to the project. This was probably my favorite talk, and I also learned how to pronounce Bleve :)</p>

<p><a href="http://www.blevesearch.com/">bleve homepage</a></p>

<h4 id="simplicity-is-complicated:184802dcbae007fe12d15202c45527c5">Simplicity is Complicated</h4>

<p>A talk given by the excellent Rob Pike co-creator of Go. He stated that even though Go is a very simple language, a lot of the complexity is hidden behind the scenes. He talked about how simplicity and complexity are part of the design and finding the right balance is a challenging task. This was good talk, and when listening I thought about the <em>go</em> keyword.</p>

<pre><code class="language-go">go someFunction()
</code></pre>

<p>This in Go is a simple way to get concurrency into your program and all the complexity of scheduling is hidden behind the scenes.</p>

<p>There were also a series of ten minute lightning talks, one of these was given by Brad Fitz about http2 in Go. http2 will be available in go 1.6.</p>

<p>Full list of dotGo videos can be found <a href="http://www.thedotpost.com/conference/dotgo-2015">here</a>.</p>

<p>Overall I really enjoyed my time at dotGo, and Paris is an amazing and buzzing city. I will never forget standing on my Hotel balcony and listening to a trumpeter playing for tips, with the noise of the city in the background.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/10/tmux-cross-platform/">
        tmux Cross Platform Config.
      </a>
    </h1>

    <span class="post-date">Oct 20, 2015</span>

    


    <p>If like me you use tmux on both Linux and OS X, then managing your tmux configuration can be a pain. The problem is there is configuration that is specific to either OS, such as copy and paste behavior. This blog post will show you how to manage your tmux configuration across platforms in a better way.</p>

<p>The first thing you want to do is create a dot file for each platform, so for Linux create <em>.tmux-linux.conf</em> and for OS X create <em>.tmux-osx.conf</em>. Create and place these files in the same location as your <em>.tmux.conf</em> file (most likely your home directory).</p>

<p>Now move any OS specific settings out of <em>.tmux.conf</em> into <em>.tmux-osx.conf</em> and <em>.tmux-linux.conf</em> respectively.</p>

<p>In your <em>.tmux.conf</em> file add the line:</p>

<pre><code class="language-bash">if-shell &quot;uname | grep -q Darwin&quot; 'source-file ~/.tmux-osx.conf' \
'source-file ~/.tmux-linux.conf'
</code></pre>

<p>Basically, when tmux reads in it&rsquo;s configuration, if the OS is &lsquo;Darwin&rsquo; (OS X) then it will read <em>.tmux-osx.conf</em> else it will read in <em>.tmux-linux.conf</em>.</p>

<p>Note: the above code snippet assumes that the three *.conf files are placed in your home directory, if they are not change the paths.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/09/go-todo/">
        Things to do before committing Go code
      </a>
    </h1>

    <span class="post-date">Sep 2, 2015</span>

    


    <p>This blog post will list some of the basic things you should really do before committing Go code into your repository.</p>

<p><strong>1)</strong> Run gofmt/goimports</p>

<p><em>gofmt</em> is probably the most popular Go tool amongst gophers. The job of <em>gofmt</em> is to
format Go packages, your code will be formatted to be consistent across your code base. For example if we have the following <em>if</em> statement:</p>

<pre><code class="language-go">if x == 42 { fmt.Println(&quot;The answer to everything&quot;) }
</code></pre>

<p>Then running <em>gofmt</em> on this will format the code to:</p>

<pre><code class="language-go">if x == 42 { 
    fmt.Println(&quot;The answer to everything&quot;) 
}
</code></pre>

<p><em>goimports</em> is a tool that does exactly what <em>gofmt</em> does, but takes it a step further and adds/removes packages. For example if you had the following code:</p>

<pre><code class="language-go">package main

import (
    &quot;log&quot;
)

func main() {
    fmt.Println(&quot;Hello&quot;)
}
</code></pre>

<p>As you can see from this code, package &lsquo;log&rsquo; is not used anywhere and package &lsquo;fmt&rsquo; has not been imported. Running <em>goimports</em> on this code transforms it to:</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

func main() {
    fmt.Println(&quot;Hello&quot;)
}
</code></pre>

<p>Running either of these tools on your code is a must, its great to see a code base using common idioms and a consistent format/style. And to me, it&rsquo;s one of main things that makes Go code bases so more approachable than code bases in other languages.</p>

<p><strong>2)</strong> Run golint</p>

<p><em>golint</em> will lint your source code and make suggestions concerning coding style.</p>

<p>see <a href="https://github.com/golang/lint">golint on github</a>.</p>

<p><strong>3)</strong> Run go vet</p>

<p>Go <em>vet</em> is another important tool, it&rsquo;s perfectly summed up by it&rsquo;s documentation:</p>

<p><em>&ldquo;Vet examines Go source code and reports suspicious constructs, such as Printf calls whose arguments do not align with the format string. Vet uses heuristics that do not guarantee all reports are genuine problems, but it can find errors not caught by the compilers.&rdquo;</em></p>

<p>If we run go <em>vet</em> on the following code:</p>

<pre><code class="language-go">fmt.Printf(&quot;%s&quot;, 42)
</code></pre>

<p>We would get the following error:</p>

<pre><code>test.go:6: arg 42 for printf verb %s of wrong type: int
exit status 1
</code></pre>

<p>Go <em>vet</em> differs from <em>golint</em>, go <em>vet</em> is concerned with correctness and <em>golint</em> is concerned with coding style.</p>

<p>see <a href="https://godoc.org/golang.org/x/tools/cmd/vet">here</a> for more information on <em>vet</em>.</p>

<p><strong>4)</strong> Run build/install/run with -race flag:</p>

<p>There is a fully integrated race detector in the go tool chain. The race detector contains complex race detection and deadlock algorithms, to help you hunt down those hard to find concurrency related bugs.</p>

<p>To enable the race detector in your code, add the -race flag on the command line:</p>

<pre><code>$ go test -race mypkg    // test the package
$ go run -race mysrc.go  // compile and run the program
$ go build -race mycmd   // build the command
$ go install -race mypkg // install the package
</code></pre>

<p>Note: Your code will run slower when you enable this flag, as the race detector is busy doing its thing :)</p>

<p><strong>5)</strong> Run a dependency management tool</p>

<p>It&rsquo;s very likely that your project will make use of 3rd party libraries. If you need to capture there versions, run a dependency management tool. Below is a list of some popular ones:</p>

<ul>
<li><a href="https://github.com/constabulary/gb">gb on github</a></li>
<li><a href="https://github.com/tools/godep">godeps on github</a></li>
<li><a href="https://github.com/Masterminds/glide">glide on github</a></li>
</ul>

<p>I have no real experience with the above tools but instead use the go 1.5 vendor experiment feature to capture dependencies.</p>

<p>I hope this lists helps you in some way in managing your Go projects. Remember, this is just a basic list, Go has numerous tools that you probably run which are essential to you or your project. The ones listed above are ones which I believe are the basics.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/08/golang-uk-conf-2015/">
        Golang UK Conference 2015
      </a>
    </h1>

    <span class="post-date">Aug 25, 2015</span>

    


    

<p><img src="https://i.imgur.com/LJfFYSS.png" alt="British Gopher" /></p>

<p>On Friday the 21st of August I attended the <a href="http://www.golanguk.com/">Golang UK conference 2015</a> held at
the amazing Brewery in London. This post is a short write up of my time at the
conference.</p>

<p>This was my first ever conference so apart from the talks, I did not know what
else to expect. Overall though, I found the conference was excellent and I met
a wide range of interesting people.</p>

<h5 id="turnout:95f078b9982a0bb9d2c4f8afc300946a">Turnout</h5>

<p>The turnout was quite big with over 250 delegates from all over the world.</p>

<h5 id="go-usage:95f078b9982a0bb9d2c4f8afc300946a">Go usage</h5>

<p>From the people I met no one was really using Go in a big way, but had an
API or a small server component written in Go. However, everyone was expecting
to increase there Go usage through out the coming year.</p>

<h5 id="talks:95f078b9982a0bb9d2c4f8afc300946a">Talks</h5>

<p>The conference consisted of 2 tracks, a main track and a side track. The talks I
went to:</p>

<ul>
<li>Opening Keynote</li>
<li>Crossing the Language Chasm</li>
<li>Building API&rsquo;s</li>
<li>Complex Concurrency Patterns in Go</li>
<li>Code Analysis</li>
<li>Understanding Memory Allocation</li>
<li>Whispered Secrets</li>
<li>The Go Community</li>
</ul>

<p>Out of all the talks, the best one was Code Analysis presented by Francesc Campoy.</p>

<h5 id="food:95f078b9982a0bb9d2c4f8afc300946a">Food :)</h5>

<p>The food served at the conference was absoutetly amazing. Many of the delgates
said that it was best food of any conference they had been to.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/08/gofmt-rewrite-rules/">
        Gofmt and Rewrite Rules
      </a>
    </h1>

    <span class="post-date">Aug 4, 2015</span>

    


    <p>One thing I absolutely love about Go is its tooling support. Whenever I use the
numerous tools I always discover something new. In this short post I will be
showing off gofmt&rsquo;s -r flag, this flag allows you to apply a rewrite rule to your
source before formatting.</p>

<p>A rewrite rule is a string in the following format:</p>

<pre><code>pattern -&gt; replacement
</code></pre>

<p>Both pattern and replacement must be valid Go expressions (more on this later), lets
apply a simple rewrite to the following code:</p>

<pre><code>// test1.go
package main

import (
    &quot;fmt&quot;
)

func main() {
    foo := &quot;Hello World&quot;

    fmt.Println(foo)
}
</code></pre>

<p>The following rewrite rule changes the variable name from &lsquo;foo&rsquo; to &lsquo;bar&rsquo;:</p>

<pre><code>$ gofmt -r='foo -&gt; bar' test1.go
</code></pre>

<p>Output:</p>

<pre><code>// test1.go
package main

import (
    &quot;fmt&quot;
)

func main() {
    bar := &quot;Hello World&quot;

    fmt.Println(bar)
}
</code></pre>

<p>We will now apply a more powerful rule to the below code:</p>

<pre><code>// test2.go
package main

func main() {
    vals := make([]int, 0)

    vals = append(vals, 15)
    vals = append(vals, 17)
    vals = append(vals, 23)

    slice := vals[1:len(vals)]

    _ = slice
}
</code></pre>

<p>The line:</p>

<pre><code>slice := vals[1:len(vals)]
</code></pre>

<p>Is not very idiomatic Go so lets change this:</p>

<pre><code>$ gofmt -r='a[b:len(a)] -&gt; a[b:]' test2.go
</code></pre>

<p>Output:</p>

<pre><code>// test2.go
package main

func main() {
    vals := make([]int, 0)

    vals = append(vals, 15)
    vals = append(vals, 17)
    vals = append(vals, 23)

    slice := vals[1:]

    _ = slice
}
</code></pre>

<p>As you can see the code was correctly transformed. Notice how the rule used the
characters &lsquo;a&rsquo; and &lsquo;b&rsquo;. If your rule uses single-character lowercase identifiers,
then these will serve as wild-cards matching arbitrary sub-expressions; these
expressions will be substituted for the same identifiers in the replacement. So
the rule:</p>

<pre><code>-r='a[b:len(a)] -&gt; a[b:]'
</code></pre>

<p>Would match:</p>

<pre><code>x := vals[1:len(vals)] // vals[1:]
y := nums[5:len(nums)] // nums[5:]
</code></pre>

<p>Were on the first match:</p>

<p>&lsquo;a&rsquo; would be substituted for &lsquo;val&rsquo; <br/>
&lsquo;b&rsquo; would be substituted for &lsquo;1&rsquo; <br/></p>

<p>And on the second match:</p>

<p>&lsquo;a&rsquo; would be substituted for &lsquo;nums&rsquo; <br/>
&lsquo;b&rsquo; would be substituted for &lsquo;5&rsquo; <br/></p>

<p>An important thing to remember when using the -r flag is that the resulting
transformation must be a syntactically valid declaration list, statement list,
or expression. So the following rule:</p>

<pre><code>-r='a[b:len(a)] -&gt; a[const]'
</code></pre>

<p>Would be syntactically incorrect (const is a reserved keyword), and you would get
the error:</p>

<pre><code>parsing replacement a[const] at 1:4: expected operand, found 'const' 
</code></pre>

<p>If you would like to learn more about rewrite rules then run:</p>

<pre><code>$ godoc gofmt
</code></pre>

<p><strong>Note</strong>: godoc gofmt reports the following at the end:</p>

<pre><code>BUGS

The implementation of -r is a bit slow.
</code></pre>

<p>:)</p>

<p><strong>Note</strong>: I am using Go version 1.4.2</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/07/go-string-concat/">
        Go and String Concatenation
      </a>
    </h1>

    <span class="post-date">Jul 26, 2015</span>

    


    

<p>When writing Go code you should try to stay away from concatenating strings using the &lsquo;+&rsquo; and &lsquo;+=&rdquo; operators.</p>

<p>Strings in Go, like many other languages (Java, C#, etc&hellip;) are immutable, this means after a string has been created it is impossible to change. Here is what the <a href="https://golang.org/ref/spec#String_types">Go Programming Language Specification</a> has to say about the string type:</p>

<p><em>&ldquo;A string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is string.&rdquo;</em></p>

<p>Lets look at an example:</p>

<pre><code>var town string = &quot;Spring&quot;
town += &quot;field&quot;
</code></pre>

<p>When you write the above code the compiler actually creates a new sequence of bytes, and assigns it to the variable &lsquo;town&rsquo;. The string &ldquo;Spring&rdquo; is then eligible for garbage collection. Here is what the heap would look like, after the above code was run:</p>

<pre><code>           &quot;Spring&quot;

town ----&gt; &quot;Springfield&quot;
</code></pre>

<p>Now if we concatenate the string &lsquo;town&rsquo; with the another string:</p>

<pre><code>town = &quot;742 Evergreen Terrace &quot; + town
</code></pre>

<p>The heap would look like this:</p>

<pre><code>           &quot;Spring&quot;

           &quot;Springfield&quot;

town ----&gt; &quot;742 Evergreen Terrace Springfield&quot;
</code></pre>

<p>If you concatenate a lot of strings using &lsquo;+&rsquo; and &lsquo;+=&rsquo; you will be generating a lot of garbage. This will make the garbage collector work harder as all those potential dead strings will need to be analyzed and freed.</p>

<p>There are two ways to concatenate string more efficiently:</p>

<h5 id="1-strings-join:09d97f42a93e7b11514ce16c8075547b">1. strings.Join()</h5>

<pre><code>town := strings.Join([]string{&quot;Spring&quot;, &quot;field&quot;}, &quot;&quot;))
</code></pre>

<h5 id="2-bytes-buffer:09d97f42a93e7b11514ce16c8075547b">2. bytes.Buffer</h5>

<pre><code>func concat(vals ...string) string {
    var buffer bytes.Buffer
    for _, s := range vals {
        buffer.WriteString(s)
    }
    return buffer.String()
}

func main() {
    town := concat(&quot;Spring&quot;, &quot;field&quot;)

    names := []string{&quot;Homer&quot;, &quot;Moe&quot;, &quot;Barney&quot;, &quot;Carl&quot;, &quot;Lenny&quot;}

    friends := concat(names...)
    ...
}
</code></pre>

<p>You can use either, I prefer using the &lsquo;concat&rsquo; method as it&rsquo;s easier to read.</p>

<p>These two methods are much more efficient as behind the scenes they allocate a variable size buffer of bytes. Which can be modified over and over again with out leaving behind a lot of unused strings.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/07/calling-c-from-go/">
        Calling C from Go
      </a>
    </h1>

    <span class="post-date">Jul 25, 2015</span>

    


    

<p>This post will show you the basics of how to call C code from a Go package.</p>

<p>Lets get started with an example:</p>

<p>Create a header file &ldquo;add.h&rdquo; with a function prototype:</p>

<pre><code>#ifndef _ADD_H_
#define _ADD_H_
int add(int, int);
#endif
</code></pre>

<p>Create the source file &ldquo;add.c&rdquo; containing the definition for add:</p>

<pre><code>#include &quot;add.h&quot;

int add(int a, int b) 
{
   return a + b;
}
</code></pre>

<p>Create a Go package &ldquo;main.go&rdquo;:</p>

<pre><code>package main

// #include &quot;add.c&quot;
import &quot;C&quot;

import (
    &quot;fmt&quot;
)

func main() {
    r := C.add(40, 2)
    fmt.Println(&quot;result = &quot;, r)
}
</code></pre>

<p>Ouptut:</p>

<pre><code>$ go build main.go
$ ./main
result = 42
</code></pre>

<p>Notice the comment above the import &ldquo;C&rdquo; statement we include add.c not add.h.</p>

<p>If import &ldquo;C&rdquo; is immediately preceded by comments, then those comments become apart of the compilation process. If there are any spaces between the comments, then those are seen as normal go comments, for example:</p>

<pre><code>// #include &lt;math.h&gt;

// #include &lt;stdio.h&gt;
// #include &lt;errno.h&gt;
import &quot;C&quot;
</code></pre>

<p>The header files stdio.h and errno.h are included as part of the compilation process, math.h is <strong>not</strong>.</p>

<h2 id="inline-c:f1759daed9e47388fe7eae5373f5e76d">Inline C</h2>

<p>You can also write C code directly in the comments, here is an example:</p>

<pre><code>package main

/*
int fortytwo()
{
    return 42;
}
*/
import &quot;C&quot;

import (
    &quot;fmt&quot;
)

func main() {
    fmt.Println(C.fortytwo)     // address
    fmt.Println(C.fortytwo())   // invocation
}
</code></pre>

<p>Output:</p>

<pre><code>$ go build inline.go
$ ./inline
0x40014a0
42
</code></pre>

<h2 id="accessing-c-structs:f1759daed9e47388fe7eae5373f5e76d">Accessing C structs</h2>

<p>Assume we have the below C struct defined in a .h or .c file:</p>

<pre><code>struct point {
    int x;
    int y;
};
</code></pre>

<p>In order to access this from a Go package, you simple prefix the type name &ldquo;point&rdquo; with &ldquo;C.struct_&rdquo;:</p>

<pre><code>func main() {
    p := C.struct_point{}
    p.x = 99
    p.y = 42
    fmt.Printf(&quot;type:   %T\n&quot;, p)
    fmt.Printf(&quot;struct: %+v\n&quot;, p)
}
</code></pre>

<p>Output:</p>

<pre><code>$ go build cstruct.go
$ ./cstruct
type:   main._Ctype_struct_point
struct: {x:99 y:42}
</code></pre>

<h2 id="controlling-the-behaviour-of-the-c-compiler:f1759daed9e47388fe7eae5373f5e76d">Controlling the behaviour of the C compiler</h2>

<p>You can pass flags to the C compiler to control its behaviour. This is done by defining a CFLAGS with a pseudo #cgo directive in the comments. In the example below, the -H flag will be passed to the C compiler (clang in my case) when it&rsquo;s invoked. The -H flag tells clang to show the header includes and nesting depth.</p>

<pre><code>package main

// #cgo CFLAGS: -H
// #include &quot;add.c&quot;
import &quot;C&quot;

import (
    &quot;fmt&quot;
)

func main() {
    r := C.add(40, 2)
    fmt.Println(&quot;result = &quot;, r)
}
</code></pre>

<p>Ouptut:</p>

<pre><code>$ go build main.go
!! this output is from clang writing to stdout because we passed the -H flag !!
. ./add.c
.. ./add.h
. /usr/include/errno.h
.. /usr/include/sys/errno.h
... /usr/include/sys/cdefs.h
.... /usr/include/sys/_symbol_aliasing.h
.... /usr/include/sys/_posix_availability.h
...

$ ./main
result = 42
</code></pre>

<h2 id="peeking-behind-the-scenes:f1759daed9e47388fe7eae5373f5e76d">Peeking behind the scenes</h2>

<p>What is happening when we build a Go package that includes an import &ldquo;C&rdquo; statement.</p>

<p>Firstly import &ldquo;C&rdquo; is a pseudo-package it is not listed in the standard library. When the go compiler sees the pseudo-package import &ldquo;C&rdquo; it runs the <strong>cgo</strong> command, this generates all the supporting infrastructure. It transforms main.go outputting some .h and .c files, these are then passed to clang to compile.</p>

<p><strong>Note:</strong> the cgo command actually invokes the gcc compiler, however on my machine gcc is an alias for clang, so it&rsquo;s clang that is doing the compiling.</p>

<p>The output from the C compiler is an object file named _cgo_.o, which contains the compiled C code. This object code (_cgo_.o) is then linked into the rest of the go binary.</p>

<p>Lets runs the cgo command directly to get a better understanding:</p>

<pre><code>$ go tool cgo main.go
</code></pre>

<p>This command will output a directory called _obj:</p>

<pre><code>$ ls _obj/  

_cgo_.o
_cgo_defun.c
_cgo_export.c
_cgo_export.h
_cgo_flags
_cgo_gotypes.go
_cgo_main.c
main.cgo1.go
main.cgo2.c
</code></pre>

<p>As stated _cgo_.o contains the compiled C code, one interesting file to browse is main.cgo2.c:</p>

<pre><code>$ cat main.cgo2.c

#line 10 &quot;/go/src/samples/main.go&quot;

 #include &quot;add.c&quot;

// Usual nonsense: if x and y are not equal, the type will be invalid
// (have a negative array count) and an inscrutable error will come
// out of the compiler and hopefully mention &quot;name&quot;.
#define __cgo_compile_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];

// Check at compile time that the sizes we use match our expectations.
#define __cgo_size_assert(t, n) __cgo_compile_assert_eq(sizeof(t), n, _cgo_sizeof_##t##_is_not_##n)

__cgo_size_assert(char, 1)
__cgo_size_assert(short, 2)
__cgo_size_assert(int, 4)
typedef long long __cgo_long_long;
__cgo_size_assert(__cgo_long_long, 8)
__cgo_size_assert(float, 4)
__cgo_size_assert(double, 8)

extern char* _cgo_topofstack(void);

#include &lt;errno.h&gt;
#include &lt;string.h&gt;

void
_cgo_7474d4d504ba_Cfunc_add(void *v)
{
    struct {
        int p0;
        int p1;
        int r;
        char __pad12[4];
    } __attribute__((__packed__)) *a = v;
    char *stktop = _cgo_topofstack();
    __typeof__(a-&gt;r) r = add(a-&gt;p0, a-&gt;p1);
    a = (void*)((char*)a + (_cgo_topofstack() - stktop));
    a-&gt;r = r;
}
</code></pre>

<p>Take a while to browse the other files, they are quite interesting.</p>

<p>I hope you enjoyed this post.</p>

<p><strong>Note:</strong> I am on OSX 10.10.4 64 bit using go version 1.4.2 and clang version 602.0.53.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/07/first/">
        First Post
      </a>
    </h1>

    <span class="post-date">Jul 25, 2015</span>

    


    <p>This is my blog. There are many like it, but this one is mine.</p>

  </div>
  
  
  
  
</div>


  </body>
</html>
