<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  

  <title> Usman Mahmood </title>

  
  <link rel="stylesheet" href="https://fallthrough.io/css/poole.css">
  <link rel="stylesheet" href="https://fallthrough.io/css/syntax.css">
  <link rel="stylesheet" href="https://fallthrough.io/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link href="https://fallthrough.io/index.xml" rel="alternate" type="application/rss+xml" title="Usman Mahmood" />

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

  <link href='http://fonts.googleapis.com/css?family=Raleway:400,300' rel='stylesheet' type='text/css'>

  <script src="//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: ['Raleway']
      }
    });
  </script>

</head>

<body>

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 style="font-size: 60px" class="brand"><a href="https://fallthrough.io">Usman Mahmood</a></h1><br/>
      <p class="lead">
       Algorithms &#43; Data Structures = Programs 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://fallthrough.io/blog">Posts</a></li>
      
        <li><a href="/about/">About </a></li>
      
      <br/>
      <li><a href="https://github.com/umahmood">Github</a></li>
      <li><a href="https://twitter.com/make_slice">Twitter</a></li>
      <li><a href="https://keybase.io/usman">Keybase</a></li>

    <br/>
    &copy; 2017 Usman Mahmood. All rights reserved.</p>
    
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2017/05/sync-pool-gc/">
        Sync.Pool is Drained During Garbage Collection
      </a>
    </h1>

    <span class="post-date">May 23, 2017</span>

    


    <p>The Go sync.Pool type stores temporary objects, and provides get and put methods. Allowing you to cache allocated but unused items for later reuse. And relieving pressure on the garbage collector.</p>

<p>The purpose of the sync.Pool type is to reuse memory between garbage collections. Which is why sync.Pool is drained during garbage collection (GC).</p>

<p>Here is an example of how to use the sync pool:</p>

<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;sync&quot;
)

var bufPool = sync.Pool{
	New: func() interface{} {
		return new(bytes.Buffer)
	},
}

func main() {
	b := bufPool.Get().(*bytes.Buffer)
	b.WriteString(&quot;What is past is prologue.&quot;)
	bufPool.Put(b)
	b = bufPool.Get().(*bytes.Buffer)
	fmt.Println(b.String())
}
</code></pre>

<p>Output:</p>

<pre><code>What is past is prologue.
</code></pre>

<p><strong>Note</strong>: When calling &lsquo;bufpool.Get&rsquo; it is not guaranteed that we will get a specific buffer from the pool. The &lsquo;Get&rsquo; method selects a random buffer from the pool, removes it from the pool and then returns it to the caller.</p>

<p>As stated before, the interesting thing to note when using sync.Pool, is that it is drained <strong>during</strong> GC. That is, all the objects within the pool are removed. Lets look at an example of this in action:</p>

<pre><code>func main() {
    b := bufPool.Get().(*bytes.Buffer)
	b.WriteString(&quot;What is past is prologue.&quot;)
	bufPool.Put(b)
	
	// never actually call runtime.GC() in your program :)
	runtime.GC() 
	
	b = bufPool.Get().(*bytes.Buffer)
	fmt.Println(b.String())
}
</code></pre>

<p>The program will no longer output &ldquo;What is past is prologue.&rdquo; because the call to runtime.GC() drained &lsquo;bufpool&rsquo;. And when we make the call to &lsquo;bufPool.Get()&rsquo;, we get a brand new buffer and not a recycled one.</p>

<p>If we look at the Go source code repository on Github. We see that within the file mgc.go, the <a href="https://github.com/golang/go/blob/3b5637ff2bd5c03479780995e7a35c48222157c1/src/runtime/mgc.go#L1190">gcStart</a> function makes a call to the function <a href="https://github.com/golang/go/blob/3b5637ff2bd5c03479780995e7a35c48222157c1/src/runtime/mgc.go#L2046">clearpools</a>. This function drains all the sync.Pool types.</p>

<p>There are other techniques that can be used to drain the sync pool, such as:</p>

<ul>
<li>Sometime before a GC</li>
<li>Sometime after a GC</li>
<li>Clock based</li>
<li>Using weak references/pointers</li>
</ul>

<p>Each of these techniques have their advantages and disadvantages. However, Draining the pool during a GC is a good technique as it is simple and does not circumvent the garbage collector.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2017/02/external-access-pi-ngrok/">
        Access Raspberry Pi Externally using ngrok
      </a>
    </h1>

    <span class="post-date">Feb 26, 2017</span>

    


    

<p>In this blog post we will set up our Raspberry Pi so it will accessed using SSH from outside our home network. Below is a diagram of the architecture:</p>

<p>[ Home Network : Raspberry Pi ] &lt;&ndash; [ ngrok ] &ndash;&gt; [ External Network ]</p>

<p>From our home network we will create a secure tunnel, through ngrok. Which we will then connect to from our external network. This will allow us to SSH into our Raspberry Pi, and manage it.</p>

<h5 id="what-is-ngrok:badb4f5b22028ec1b44a78365cf64846">What is ngrok?</h5>

<p>ngrok is a fantastic tool which allows you to create secure tunnels to localhost. So you can do things like expose a local server behind a NAT or firewall to the internet. See the <a href="https://ngrok.com/">ngrok</a> homepage for more information.</p>

<p>Lets get started!</p>

<h4 id="step-1-enable-passwordless-ssh-access:badb4f5b22028ec1b44a78365cf64846">Step 1: Enable Passwordless SSH Access</h4>

<p>You need to configure your Pi for SSH access. Follow the steps described in the following link (very carefully):</p>

<ul>
<li><a href="https://www.raspberrypi.org/documentation/remote-access/ssh/passwordless.md">Passwordless SSH Access - raspberrypi.org</a></li>
</ul>

<p>By the end, you should be able to type:</p>

<pre><code>$ ssh USER@Pi-IP-ADDRESS
</code></pre>

<p>And connect to your Raspberry Pi without a password prompt. For example:</p>

<pre><code>$ ssh pi@192.168.0.42

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sat Feb 25 20:24:30 2017 from 192.168.0.42

pi@raspberrypi ~ $ 
</code></pre>

<p>No prompt for a password.</p>

<p><strong>Note</strong>: the computer you generated the SSH keys on (and copied to the Pi). Is the computer you will be using to connect to your Pi, from the external network.</p>

<h4 id="step-2-install-ngrok-on-your-raspberry-pi:badb4f5b22028ec1b44a78365cf64846">Step 2: Install ngrok on your Raspberry Pi</h4>

<p>Go <a href="https://ngrok.com/download">here</a> and follow the instructions to install ngrok on your Pi.</p>

<h4 id="step-3-run-ngrok-on-your-raspberry-pi:badb4f5b22028ec1b44a78365cf64846">Step 3: Run ngrok on your Raspberry Pi</h4>

<p>Run ngrok with the following options:</p>

<pre><code>pi@raspberrypi ~ $ ngrok tcp 22
</code></pre>

<h4 id="step-4-copy-ngrok-host-and-port:badb4f5b22028ec1b44a78365cf64846">Step 4: Copy ngrok Host and Port</h4>

<p>Once ngrok starts, it will display a <em>tcp://</em> address on the forwarding line, for example:</p>

<blockquote>
<p>Forwarding tcp://123xyz0.tcp.ngrok.io:17684 -&gt; localhost:22</p>
</blockquote>

<p>Copy the host name <em>123xyz0.tcp.ngrok.io</em> and the port <em>17684</em>.</p>

<p><strong>Note</strong>: the host name and port will be different for you.</p>

<h4 id="step-5-edit-ssh-config-file:badb4f5b22028ec1b44a78365cf64846">Step 5: Edit SSH config file</h4>

<p>In step one you generated some ssh keys on your computer, and then copied them to the raspberry Pi. On the computer you generated the SSH keys on, add the following details to <em>~/.ssh/config</em>:</p>

<pre><code>Host ngrok
        HostName 123xyz.tcp.ngrok.io
        IdentityFile ~/.ssh/id_rsa
</code></pre>

<p>Again, the host name will be different for you.</p>

<p><strong>Note</strong>: we are using the same key we copied over to the Pi in step one, you can generate new SSH keys if you like.</p>

<h4 id="step-6-access-the-raspberry-pi-from-outside-your-network:badb4f5b22028ec1b44a78365cf64846">Step 6: Access the Raspberry Pi from outside your network</h4>

<p>Now with your computer <strong>not</strong> connected to your home network, type the command:</p>

<pre><code>$ ssh pi@ngrok -p 17684
</code></pre>

<p>Change the username and port to match yours.</p>

<p>You should now be connected to your Raspberry Pi using SSH through ngrok.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2017/02/pi-slow-ssh-fix/">
        Raspberry Pi Slow SSH Fix
      </a>
    </h1>

    <span class="post-date">Feb 20, 2017</span>

    


    <p>If you SSH into your Raspberry Pi and have noticed a lag when typing characters into the terminal. Then the following fix may get rid of the lag (it worked for me!).</p>

<p>Log into your Raspberry Pi and type:</p>

<pre><code>$ sudo nano /etc/ssh/sshd_config
</code></pre>

<p>At the bottom of the config file add:</p>

<pre><code>UseDns no
</code></pre>

<p>Save the file, then restart sshd:</p>

<pre><code>$ service ssh restart
</code></pre>

<p>Or better, reboot your Raspberry Pi:</p>

<pre><code>$ sudo reboot
</code></pre>

<p>SSH&rsquo;ing into your Raspberry Pi should no longer be slow after these steps. 🤞</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/12/runtime-user-panics/">
        Runtime and User Level Panics in Go
      </a>
    </h1>

    <span class="post-date">Dec 8, 2016</span>

    


    <p>How can our application code detect the difference between a runtime panic and a user level panic? Before answering this question. Let&rsquo;s take a look at the difference between a runtime panic, and user level panic.</p>

<p>A runtime panic is one thrown by the Go runtime, there are many things that can trigger a runtime panic. An example of the the most common runtime panic would be attempting to index an array out of bounds. The Go runtime would detect the illegal access and call the built-in panic function.</p>

<p>A user level panic would be were code outside the runtime i.e. your code, 3rd partly library, etc&hellip; makes a call to the built-in panic function:</p>

<pre><code>panic(&quot;he's dead jim&quot;)
</code></pre>

<p>In Go 1.7 a change was made to the panic values thrown by the runtime. From the <a href="https://golang.org/doc/go1.7#runtime">1.7 release notes </a> it states:</p>

<p><em>All panics started by the runtime now use panic values that implement both the builtin error, and runtime.Error, as required by the language specification.</em></p>

<p>When the runtime throws a panic it will call the built-in panic function. With a value which implements the <em>runtime.Error</em> interface. When user level code calls the built-in panic function. It will provide a value which does not implement the <em>runtime.Error</em> interface.</p>

<p>Lets look at a code example:</p>

<pre><code>package main

import (
	&quot;errors&quot;
	&quot;fmt&quot;
	&quot;runtime&quot;
)

func runtimePanic() {
	var a []int
	// index out of range, will trigger a runtime panic
	b := a[99]
	_ = b
}

func nonRuntimePanic() {
	panic(errors.New(&quot;:(&quot;))
}

func main() {
	defer func() {
		if x := recover(); x != nil {
			if _, ok := x.(runtime.Error); ok {
				fmt.Println(&quot;this is a runtime panic error&quot;)
			} else {
				fmt.Println(&quot;this is a non-runtime panic error&quot;)
			}
		}
	}()
	// nonRuntimePanic()
	runtimePanic()
}

</code></pre>

<p>In our defer closure we call the built-in recover function. And then use the return value, to see if the type satisfies the <em>runtime.Error</em> interface.</p>

<p>If we run this code, we will get the output:</p>

<pre><code>this is a runtime panic error
</code></pre>

<p>If we uncomment the call to <em>nonRuntimePanic</em>, and then run the code again, we will get the output:</p>

<pre><code>this is a non-runtime panic error
</code></pre>

<p>Now we can distinguish between runtime and user level panics. This information may be useful if your are determining whether to rescue your application from a panic, or to let it crash.</p>

<p>Useful links:</p>

<p><a href="https://golang.org/pkg/runtime/#Error">runtime.Error Documentation</a></p>

<p><a href="https://golang.org/ref/spec#Run_time_panics">Run-time panics</a></p>

<p><a href="https://golang.org/doc/go1.7#runtime">Go 1.7 Release Notes</a></p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/11/git-empty-commit/">
        Creating Empty Git Commits
      </a>
    </h1>

    <span class="post-date">Nov 29, 2016</span>

    


    

<p>You may not know it, but Git allows you to create an empty commit in to your repo. It doesn&rsquo;t like it, but you can do it any way.</p>

<p>An empty commit is one where you don&rsquo;t actually commit any code changes i.e. if you <em>git status</em> your repo, you get the message:</p>

<pre><code>On branch master
nothing to commit, working tree clean
</code></pre>

<p>Why would you want to create an empty commit? You may want to communicate changes, which have nothing to do with code. But you have updated something that you want the rest of the team to know about. And you feel that communicating this via the git log make sense.</p>

<h4 id="creating-an-empty-commit:80d2821c8306d8d07d9c8b746d39fb7b">Creating an empty commit</h4>

<p>Start by creating a repo:</p>

<pre><code>$ mkdir test 
$ cd test 
$ git init 
$ echo &quot;hello world&quot; &gt;&gt; hello.txt 
$ git add hello.txt 
$ git commit -m &quot;initial commit&quot; 
</code></pre>

<p>Now we have a repo with one commit and nothing else to commit:</p>

<pre><code>$ git status
On branch master
nothing to commit, working tree clean
</code></pre>

<p>We can now use the <em>&ndash;allow-empty</em> flag to insert an empty commit:</p>

<pre><code>$ git commit -m &quot;this is an empty commit&quot; --allow-empty
[master 02cdd7f] this is an empty commit
</code></pre>

<p>Lets see what the git log looks like:</p>

<pre><code>$ git log
commit 02cdd7f74c0fe4219a061e94066251dbf1137475
Author: Philip J. Fry &lt;fry@planet-express.com&gt; 
Date:   Thu Dec 01 21:24:28 2016 +0000

    this is an empty commit

commit f503c2ccf476b144f69108a842782464dd3ca61e
Author: Philip J. Fry &lt;fry@planet-express.com&gt; 
Date:   Thu Dec 01 21:15:40 2016 +0000

    initial commit
</code></pre>

<p>We can also create an empty commit with an empty commit message. Using the <em>&ndash;allow-empty-message</em> flag:</p>

<pre><code>$ git commit --allow-empty-message --allow-empty
[master 8546295]

$ git log
commit 85462959fedf63fd4a59c578caccef4df8cceff8
Author: Philip J. Fry &lt;fry@planet-express.com&gt; 
Date:   Thu Dec 01 21:57:47 2016 +0000

commit 02cdd7f74c0fe4219a061e94066251dbf1137475
Author: Philip J. Fry &lt;fry@planet-express.com&gt; 
Date:   Thu Dec 01 21:24:28 2016 +0000

    this is an empty commit

commit f503c2ccf476b144f69108a842782464dd3ca61e
Author: Philip J. Fry &lt;fry@planet-express.com&gt; 
Date:   Thu Dec 01 21:15:40 2016 +0000

    initial commit
</code></pre>

<p>Thats it! if you want to read more about the flags discussed go <a href="https://git-scm.com/docs/git-commit#git-commit---allow-empty">here</a>.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/11/git-commit-change-date/">
        Changing the Date of Git Commits
      </a>
    </h1>

    <span class="post-date">Nov 15, 2016</span>

    


    <p>Have you ever looked at peoples Github contribution timelines and seen a word or some ASCII art. This is done by creating a repo, then manipulating the dates of commits, to create the desired design.</p>

<p>This blog post is not about creating funky pieces of art in your Github commit history timeline. But instead, shows you how to change the date of a commit using Git.</p>

<p>When you make a git commit you can actually set the date of the commit to anything you want. Lets get started.</p>

<p>First, you have to set two environment variables - <em>GIT_AUTHOR_DATE</em> and <em>GIT_COMMITTER_DATE</em>, like so:</p>

<pre><code>$ export GIT_AUTHOR_DATE=&quot;Wed Jan 10 14:00 2099 +0100&quot;
$ export GIT_COMMITTER_DATE=&quot;Wed Jan 10 14:00 2099 +0100&quot;
</code></pre>

<p>Create a git repo:</p>

<pre><code>$ mkdir test
$ cd test
$ git init
$ echo &quot;hello world&quot; &gt;&gt; hello.txt
$ git add hello.txt
</code></pre>

<p>Now lets commit our changes:</p>

<pre><code>$ git commit -m &quot;initial commit&quot;
$ git log
commit 80b2d1f499d6ae455a4f87f68e107b275abfefe8
Author: Philip J. Fry &lt;fry@planet-express.com&gt;
Date:   Wed Jan 10 14:00:00 2099 +0100

    initial commit
</code></pre>

<p>You can see the date of our commit has changed, rather the being the current date/time, it is set to day in the year 2099.</p>

<p>If you want to change the date of a commit in the past, I recommend reading this <a href="http://eddmann.com/posts/changing-the-timestamp-of-a-previous-git-commit/">blog post</a>.</p>

<p>Useful links:</p>

<p><a href="https://git-scm.com/docs/git-commit#_date_formats">Git commit date formats</a></p>

<p><a href="http://eddmann.com/posts/changing-the-timestamp-of-a-previous-git-commit/">Changing the timestamp of a previous Git commit</a></p>

<p><a href="https://github.com/gelstudios/gitfiti">gitfiti - abusing github commit history for the lulz</a></p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/10/using-sub-tests-benchmarks/">
        Using Subtests and Sub-benchmarks in Go
      </a>
    </h1>

    <span class="post-date">Oct 22, 2016</span>

    


    

<p>In this post we will walk through an example of how to use the new subtests and sub-benchmarks functionality introduced in Go 1.7.</p>

<h4 id="subtests:ab65b34deed84f4e72ae56b7904d376a">Subtests</h4>

<p>One of the nifty features in Go is the ability to write table driven tests. For example, if we wanted to test the function:</p>

<pre><code class="language-go">func Double(n int) int {
    return n * 2
}
</code></pre>

<p>Then we could write a table driven test as follows:</p>

<pre><code class="language-go">func TestDouble(t *testing.T) {
	testCases := []struct {
		n    int
		want int
	}{
		{2, 4},
		{4, 10},
		{3, 6},
	}
	for _, tc := range testCases {
		got := Double(tc.n)
		if got != tc.want {
			t.Errorf(&quot;fail got %v want %v&quot;, got, tc.want)
		}
	}
}
</code></pre>

<p><strong>Note:</strong> The test case {4, 10} is present to make the test fail, 4 * 2 != 10 😃.</p>

<p>If we run this test, we get the following output:</p>

<pre><code>$ go test -v
=== RUN   TestDouble
--- FAIL: TestDouble (0.00s)
        example_test.go:25: fail got 8 want 10
FAIL
exit status 1
FAIL    example    0.005s
</code></pre>

<p>The problem here is that we don&rsquo;t know which table test case failed. It would be better, if we could identify a table test case, and display its name in the output if it fails.</p>

<p>This is what subtests in GO 1.7 allow us to do. The <em>testing.T</em> type now has a <em>Run</em> method, were the first argument is a string (the name of the test). And the second argument is a function. Below we re-implement the above test, using the <em>Run</em> method:</p>

<pre><code class="language-go">func TestDouble(t *testing.T) {
	testCases := []struct {
		n    int
		want int
	}{
		{2, 4},
		{4, 10},
		{3, 6},
	}
	for _, tc := range testCases {
		t.Run(fmt.Sprintf(&quot;input_%d&quot;, tc.n), func(t *testing.T) {
			got := Double(tc.n)
			if got != tc.want {
				t.Errorf(&quot;fail got %v want %v&quot;, got, tc.want)
			}
		})
	}
}
</code></pre>

<p>A few things to note here are that one, we are setting the name of the test to the &lsquo;n&rsquo; value of the test case. So our tests are named &ldquo;input_2&rdquo;, &ldquo;input_3&rdquo; and &ldquo;input_4&rdquo;. And two, for the second parameter we are passing in a closure which has the same method signature as a normal test.</p>

<p>If we run this test, we get the following output:</p>

<pre><code>$ go test -v
=== RUN   TestDouble
=== RUN   TestDouble/input_2
=== RUN   TestDouble/input_3
=== RUN   TestDouble/input_4
--- FAIL: TestDouble (0.00s)
    --- PASS: TestDouble/input_2 (0.00s)
    --- PASS: TestDouble/input_3 (0.00s)
    --- FAIL: TestDouble/input_4 (0.00s)
        example_test.go:43: fail got 8 want 10
FAIL
exit status 1
FAIL    example    0.006s
</code></pre>

<p>This time we get a more detailed output, we can see that &ldquo;input_4&rdquo; was the failing test case from the table. And the pass/fail status of each individual table test case.</p>

<p>We can run a subset of our table tests, by matching the unique names set for them (the first parameter to the Run method), as follows:</p>

<pre><code>$ go test -v -run=&quot;TestZap/input_2&quot;
=== RUN   TestZap
=== RUN   TestZap/input_2
--- PASS: TestZap (0.00s)
    --- PASS: TestZap/input_2 (0.00s)
PASS
ok      example    0.008s
</code></pre>

<p>Running many tests, by matching the test names:</p>

<pre><code>$ go test -v -run=&quot;TestZap/input_[1-3]&quot;
=== RUN   TestZap
=== RUN   TestZap/input_2
=== RUN   TestZap/input_3
--- PASS: TestZap (0.00s)
    --- PASS: TestZap/input_2 (0.00s)
    --- PASS: TestZap/input_3 (0.00s)
PASS
ok      example    0.006s
</code></pre>

<p>Here <em>&ldquo;input[1-3]&rdquo;</em> matched _&ldquo;input<em>2&rdquo;</em> and _&ldquo;input<em>3&rdquo;</em> but not _&ldquo;input<em>4&rdquo;</em>.</p>

<h4 id="sub-benchmarks:ab65b34deed84f4e72ae56b7904d376a">Sub-benchmarks</h4>

<p>Unlike table driven testing there was no equal approach for benchmarking. But now in Go 1.7, we have the ability to create table driven benchmarks. Imagine we need to benchmark the following function:</p>

<pre><code class="language-go">func AppendStringN(s string, n int) {
	a := make([]string, 0)
	for i := 0; i &lt; n; i++ {
		a = append(a, s)
	}
}  
</code></pre>

<p>We can define a top-level benchmark function like this:</p>

<pre><code class="language-go">func BenchmarkAppendStringN(b *testing.B) {
	benchmarks := []struct {
		fruit string
		n     int
	}{
		{fruit: &quot;apple&quot;, n: 10},
		{fruit: &quot;pear&quot;, n: 20},
		{fruit: &quot;mango&quot;, n: 40},
		{fruit: &quot;berry&quot;, n: 60},
		{fruit: &quot;banana&quot;, n: 80},
		{fruit: &quot;orange&quot;, n: 100},
	}
	for _, bm := range benchmarks {
		b.Run(bm.fruit, func(b *testing.B) {
			for i := 0; i &lt; b.N; i++ {
				AppendStringN(bm.fruit, bm.n)
			}
		})
	}
}
</code></pre>

<p>The <em>Run</em> methods signature is the same as described above. But for the <em>testing.B</em> type, rather than the <em>testing.T</em> type. Our benchmark names are set to &ldquo;apple&rdquo;, &ldquo;pear&rdquo;, &ldquo;mango&rdquo;, etc&hellip;</p>

<p>If we run this benchmark, we get the following output:</p>

<pre><code>$ go test -v -run=&quot;xxx&quot; -bench=.
BenchmarkAppendStringN/apple-8           3000000               495 ns/op
BenchmarkAppendStringN/pear-8            2000000               713 ns/op
BenchmarkAppendStringN/mango-8           1000000              1101 ns/op
BenchmarkAppendStringN/berry-8           1000000              1156 ns/op
BenchmarkAppendStringN/banana-8          1000000              1803 ns/op
BenchmarkAppendStringN/orange-8          1000000              1153 ns/op
PASS
ok      example_test    9.428s
</code></pre>

<p>An important thing to note is that, each time <em>b.Run</em> is invoked it creates a separate benchmark. The outer benchmark function (BenchmarkAppendStringN) is only run once and it is not measured.</p>

<p>One last thing to mention is that, like subtests. You can run individual benchmarks by there set unique names. Below, we run just the &ldquo;berry&rdquo; benchmark:</p>

<pre><code>$ go test -v -run=&quot;xxx&quot; -bench=&quot;/berry&quot;
BenchmarkAppendStringN/berry-8           1000000              1143 ns/op
PASS
ok      subtestbench    1.165s
</code></pre>

<p>I hope you have found this blog post helpful.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/08/svg-sprites/">
        SVG Sprites
      </a>
    </h1>

    <span class="post-date">Aug 16, 2016</span>

    


    <p>Within an single SVG file we can define many sprites. This consists of merging all your SVG sprites into a single .svg image file. Every sprite is wrapped in a &lsquo;symbol&rsquo; tag, like this:</p>

<pre><code>&lt;svg class=&quot;character&quot; width=&quot;100pt&quot; height=&quot;100pt&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
    &lt;symbol id=&quot;circle-red&quot; viewBox=&quot;0 0 100 100&quot;&gt;    
      &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;3&quot; fill=&quot;red&quot; /&gt;
    &lt;/symbol&gt;
    &lt;symbol id=&quot;circle-black&quot; viewBox=&quot;0 0 100 100&quot;&gt;    
      &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;3&quot; /&gt;
    &lt;/symbol&gt;
&lt;/svg&gt;
</code></pre>

<p>We can then use HTML or CSS to pick out each part of the image:</p>

<pre><code>&lt;hmtl&gt;
  &lt;body&gt;
     &lt;svg class=&quot;c-red&quot; &gt;
            &lt;use xlink:href=&quot;test.svg#circle-red&quot;&gt;&lt;/use&gt;
        &lt;/svg&gt;
        &lt;svg class=&quot;c-black&quot; &gt;
            &lt;use xlink:href=&quot;test.svg#circle-black&quot;&gt;&lt;/use&gt;
        &lt;/svg&gt;        
  &lt;/body&gt;
&lt;/hmtl&gt;
</code></pre>

<p>We can animate the sprite with CSS:</p>

<pre><code>&lt;style type=&quot;text/css&quot;&gt;
    .c-black:hover {
        fill: #fe2fd0;
    }
&lt;style&gt;
</code></pre>

<p>If creating an SVG sprite file seems tedious or error prone. You can use a tool like <a href="https://github.com/w0rm/gulp-svgstore">gulp-svgstore</a> to automate the process. And generate a single SVG file from your individual sprite files.</p>

<p>One of the advantages of using SVG sprites are the improved page load times. One of the disadvantages of using SVG sprites, is that when linking the &lsquo;use&rsquo; tag to the &lsquo;symbol&rsquo; tag, the image gets injected into the <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM">Shadow DOM</a>. Meaning we lose some CSS capabilities, and cannot apply some styling to the SVG image.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/06/update_packages/">
        Updating Third Party Packages in Go
      </a>
    </h1>

    <span class="post-date">Jun 11, 2016</span>

    


    <p>Just a short post on how to update packages using <em>go get</em>.</p>

<p>To update all third party packages in your <em>GOPATH</em> use the following command:</p>

<blockquote>
<p>go get -u all</p>
</blockquote>

<p>To update a specific package, just provide the full package name to <em>go get</em>:</p>

<blockquote>
<p>go get -u github.com/gorilla/mux</p>
</blockquote>

<p>What about vendor-ed packages? These are updated in exactly the same way as above:</p>

<blockquote>
<p>go get -u my-project/vendor/megacorp/foo</p>
</blockquote>

<p>If you want more information about your <em>GOPATH</em>, run the command:</p>

<blockquote>
<p>go help gopath</p>
</blockquote>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2016/03/sort-stable/">
        sort.Sort &amp; sort.Stable
      </a>
    </h1>

    <span class="post-date">Mar 13, 2016</span>

    


    <p>Go 1.6 made improvements to the Sort function in the sort package. It was improved to make fewer calls to the Less and Swap methods. Here are some benchmarks showing the performance of sort.Sort in Go 1.5 vs 1.6:</p>

<pre><code>Sort []int with Go 1.5
BenchmarkSort_1-4       20000000              67.2 ns/op
BenchmarkSort_10-4      10000000               227 ns/op
BenchmarkSort_100-4       500000              3863 ns/op
BenchmarkSort_1000-4       30000             52189 ns/op

Sort []int with Go 1.6
BenchmarkSort_1-4       20000000              64.7 ns/op
BenchmarkSort_10-4      10000000               137 ns/op
BenchmarkSort_100-4       500000              2849 ns/op
BenchmarkSort_1000-4       30000             46949 ns/op
</code></pre>

<p><em>source: <a href="https://talks.golang.org/2016/state-of-go.slide#24">state of go</a></em></p>

<p>Sort does not use a stable sorting algorithm, it does not make any guarantees about the final order of equal values. A stable sort algorithm, is one in which items which have the same key stay in the same relative order during the sort. The sorting algorithms mergesort and radixsort are stable, were as quicksort, heapsort and shellsort are not stable. If this property is important to your application then you may want to use sort.Stable.</p>

<p><a href="https://golang.org/src/sort/sort.go?s=5443:5468#L211">sort.Sort</a> under the hood uses the quicksort algorithm, were as <a href="https://golang.org/src/sort/sort.go?s=10143:10170#L336">sort.Stable</a> uses insertion sort. Below is an example of Sort and Stable in action:</p>

<pre><code>type byLength []string

func (b byLength) Len() int           { return len(b) }
func (b byLength) Less(i, j int) bool { return len(b[i]) &lt; len(b[j]) }
func (b byLength) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }

func main() {
    values1 := []string{&quot;ball&quot;, &quot;hell&quot;, &quot;one&quot;, &quot;joke&quot;, &quot;fool&quot;, &quot;moon&quot;, &quot;two&quot;}
    sort.Sort(byLength(values1))
    fmt.Println(&quot;sort.Sort&quot;, values1)
    
    values2 := []string{&quot;ball&quot;, &quot;hell&quot;, &quot;one&quot;, &quot;joke&quot;, &quot;fool&quot;, &quot;moon&quot;, &quot;two&quot;}
    sort.Stable(byLength(values2))
    fmt.Println(&quot;sort.Stable&quot;, values2)
}
</code></pre>

<p>Output:</p>

<pre><code>sort.Sort   [two one hell joke fool moon ball]
sort.Stable [one two ball hell joke fool moon]
</code></pre>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/12/defer-statement/">
        The Defer Statement
      </a>
    </h1>

    <span class="post-date">Dec 14, 2015</span>

    


    

<p>The Go programming language has a defer statement that allows for a function call to be run just before the currently running function returns. Here is how the defer statement is explained in the language specification:</p>

<p><em>&ldquo;A &ldquo;defer&rdquo; statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.&rdquo;</em></p>

<p>Here is example usage of the defer statement:</p>

<pre><code class="language-go">func DoWork(f Foo) {
    defer f.CleanUp()
    f.DoTask()
}
</code></pre>

<p>The function call in the defer statement (CleanUp), happens just before the function &lsquo;DoWork&rsquo; exits. Below I have listed some properties of the defer statement:</p>

<h3 id="defer-d-functions-are-executed-in-lifo:c0ee3214aa0f030d3b7e9ff843504550">Defer&rsquo;d functions are executed in LIFO</h3>

<p>Given the following program:</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func a() {
	defer fmt.Println(&quot;a0&quot;)
	defer fmt.Println(&quot;a1&quot;)
	b()
}	
	
func b() {
	defer fmt.Println(&quot;b&quot;)
	c()
}


func c() {
	defer fmt.Println(&quot;c&quot;)
}

func main() {
	a()
}
</code></pre>

<p>Here is what the defer&rsquo;d queue looks like:</p>

<p>Front : [ fmt.Println(&ldquo;c&rdquo;) ][ fmt.Println(&ldquo;b&rdquo;) ][ fmt.Println(&ldquo;a1&rdquo;) ][ fmt.Println(&ldquo;a0&rdquo;) ]</p>

<p>And the output:</p>

<pre><code class="language-text">c
b
a1
a0
</code></pre>

<h3 id="defer-d-functions-execute-even-if-the-function-panics:c0ee3214aa0f030d3b7e9ff843504550">Defer&rsquo;d functions execute even if the function panics</h3>

<p>In the following program the method &lsquo;Space&rsquo; panics, but the defer&rsquo;d function queued up still executes.</p>

<pre><code class="language-go">func Space() {
    defer fmt.Println(&quot;I'm a rocket ship on my way to Mars&quot;)
    panic(&quot;On a collision course&quot;)
}
</code></pre>

<p>Output:</p>

<pre><code class="language-text">I'm a rocket ship on my way to Mars
panic: On a collision course

goroutine 1 [running]:
main.Space()
	/tmp/sandbox062698335/main.go:46 +0x160
main.main()
	/tmp/sandbox062698335/main.go:51 +0x20
</code></pre>

<p>When a panic function executes, it begins to unwind the stack executing any defer statements as it goes.</p>

<h3 id="arguments-are-evaluated-when-the-defer-statement-is-encountered:c0ee3214aa0f030d3b7e9ff843504550">Arguments are evaluated when the defer statement is encountered</h3>

<p>Take the following example:</p>

<pre><code class="language-go">func Foo() {
    var x int
    defer fmt.Println(&quot;value of x =&quot;, x)
    x = x + 1
    fmt.Println(&quot;value of x =&quot;, x)
}
</code></pre>

<p>You may expect the program to output:</p>

<pre><code class="language-text">value of x = 1
value of x = 1
</code></pre>

<p>But instead the output is:</p>

<pre><code class="language-text">value of x = 1
value of x = 0  // defer'd function call output
</code></pre>

<p>The reason for this is before the defer&rsquo;d function was queued, it&rsquo;s arguments were evaluated and saved (x = 0). When the defer&rsquo;d function was executed, rather than seeing that x == 1, it instead output the value of x it saved previously. The defer section in the Go language specification states:</p>

<p><em>&ldquo;Each time a &ldquo;defer&rdquo; statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked.&rdquo;</em></p>

<p>If we would like to have the arguments evaluated when the defer executes, wrap the function in a closure:</p>

<pre><code class="language-go">func Foo() {
    var x int
    defer func() {
        fmt.Println(&quot;value of x =&quot;, x) 
    }
    x = x + 1
    fmt.Println(&quot;value of x =&quot;, x)
}
</code></pre>

<p>Output:</p>

<pre><code class="language-text">value of x = 1
value of x = 1
</code></pre>

<h3 id="defer-d-functions-can-access-named-parameters:c0ee3214aa0f030d3b7e9ff843504550">Defer&rsquo;d functions can access named parameters</h3>

<p>In the following example (taken from the defer section of the language specification):</p>

<pre><code class="language-go">// f returns 1
func f() (result int) {
	defer func() {
		result++
	}()
	return 0
}
</code></pre>

<p>You can see that defer&rsquo;d functions can access and modify named parameters. Notice how the defer in function f is a closure, otherwise we could not capture the most up to date value of &lsquo;result&rsquo; or modify it.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/12/channel-axioms/">
        Go Channel Axioms
      </a>
    </h1>

    <span class="post-date">Dec 14, 2015</span>

    


    

<p>A while ago I was watching a tech talk by Blake Caldwell on <a href="https://www.youtube.com/watch?v=PyBJQA4clfc">Building Resilient Services with Go</a>. In his presentation he had a slide which listed go channel axioms. I have listed his channel axioms here and provided some short code snippets to hopefully clarify them.</p>

<h3 id="a-send-to-a-nil-channel-blocks-forever:3c6d760ac1dd0a5b6f008ac700644390">A send to a nil channel blocks forever</h3>

<pre><code class="language-go">var ch chan bool
ch &lt;- true // will always block
</code></pre>

<p>We declare a channel &lsquo;ch&rsquo; but do not initialize it (with make), so it is a nil channel. We then attempt to <strong>send</strong> a value down the channel, this causes a blocking operation.</p>

<h3 id="a-receive-from-a-nil-channel-blocks-forever:3c6d760ac1dd0a5b6f008ac700644390">A receive from a nil channel blocks forever</h3>

<pre><code class="language-go">var ch chan bool
v := &lt;-ch // will always block
</code></pre>

<p>We declare a channel &lsquo;ch&rsquo; but do not initialize it (with make), so it is a nil channel, We then attempt to <strong>receive</strong> a value from the channel, this causes a blocking operation.</p>

<h3 id="a-send-to-a-closed-channel-panics:3c6d760ac1dd0a5b6f008ac700644390">A send to a closed channel panics</h3>

<pre><code class="language-go">ch := make(chan bool)
...
close(ch)
...
ch &lt;- true // panics!
</code></pre>

<p>We initialize a channel &lsquo;ch&rsquo; then later close the channel, and then later attempt to <strong>send</strong> a value down the channel. This causes a panic, and we receive a stack trace. In this case, before we send a value down the channel, we may want check if the channel is open:</p>

<pre><code class="language-go">if v, ok := &lt;-ch; ok {
    // ch is open
}
</code></pre>

<h3 id="a-receive-from-a-closed-channel-returns-the-zero-value-immediately:3c6d760ac1dd0a5b6f008ac700644390">A receive from a closed channel returns the zero value immediately</h3>

<pre><code class="language-go">ch := make(chan int)
...
close(ch)
...
v := &lt;-ch // v = 0
</code></pre>

<p>We initialize a channel &lsquo;ch&rsquo; then later close the channel, and then later attempt to <strong>receive</strong> a value from the channel. This causes the zero value to be returned immediately, this is a non-blocking operation.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/11/dotgo-eu-2015/">
        dotGo 2015
      </a>
    </h1>

    <span class="post-date">Nov 12, 2015</span>

    


    

<p><img src="https://i.imgur.com/uiLTeK2.png" alt="Dot conf. logo" /></p>

<p>On Monday the 9th of November I was in Paris attending dotGo, the European Go conference. This blog post is a summary of my time there.</p>

<h3 id="pre-conference:184802dcbae007fe12d15202c45527c5">Pre-Conference</h3>

<p>The day before the conference, the Paris tech talks group organized a pre-conference meetup/party. There were a large number of delegates who turned up and the meet up consisted of about six or seven talks. The talks were about how individuals at there respective companies were using Go. All the projects demoed and talked about were network related i.e. using Go to write a load balancer which solved a particular problem. After the talks, there was a chance to socialize and eat pizza with other gophers :).</p>

<h3 id="venue:184802dcbae007fe12d15202c45527c5">Venue</h3>

<p>On the day of the conference I made my way down to the venue Théâtre de Paris. This venue was absolutely beautiful, the high ceilings, the seating, the theatre boxes and stage. Made this venue truly great, and I was very grateful that the building owners allowed the conference to take place there.</p>

<h3 id="talks:184802dcbae007fe12d15202c45527c5">Talks</h3>

<p>dotGo is a single track conference which I prefer, as I always have a hard time making my mind up about which talks to attend. Here is a summary of the talks:</p>

<h4 id="microservices:184802dcbae007fe12d15202c45527c5">Microservices</h4>

<p>This talk was given by Peter Bourgon the creator of Gokit. The talk centered around his thoughts, opinions and efforts of getting people to adopt microservices in organizations.</p>

<p><a href="https://github.com/go-kit/kit">gokit on github</a></p>

<h4 id="tools-for-working-with-go-code:184802dcbae007fe12d15202c45527c5">Tools for working with Go code</h4>

<p>This talk was given by Fatih Arslan the creator of Vim-go. This was a great talk were you were introduced to a wide range of tools that exist in the Go ecosystem. Tools such as <em>gorename</em>, <em>generate</em> and <em>oracle</em> were presented along with examples on how to use them.</p>

<h4 id="the-docker-trail:184802dcbae007fe12d15202c45527c5">The Docker Trail</h4>

<p>This talk was given by Jessica Frazelle who is a core team member at Docker. She talked about three odd things the team at Docker noticed and how they went about debugging and fixing them.</p>

<h4 id="applied-concurrency-in-go:184802dcbae007fe12d15202c45527c5">Applied Concurrency in Go</h4>

<p>A talk given by Matt Aimonetti who is the co-founder and CTO of Splice. Matt was running Go code (which used concurrency) on an Arduino which made some LED&rsquo;s blink according to some rules. He ran various versions of the code all of which contained concurrency related bugs, he fixed the bugs as he went along. Showing all the the mistakes we usually make when writing concurrent code.</p>

<h4 id="functional-go:184802dcbae007fe12d15202c45527c5">Functional Go?</h4>

<p>A talk given by the excellent Francesc Campoy Flores a member of the Google Go team. This talk concentrated on his efforts to use Go in a functional manner, after his experiences with Haskell. The functional code he wrote for the problem he was trying solve was scary, he really was actively working against the language (something he admitted). It was a fun talk though.</p>

<h4 id="the-other-side-of-go-programming-pictures:184802dcbae007fe12d15202c45527c5">The Other Side of Go: Programming Pictures</h4>

<p>This talk was given by Anthony Starks the creator of SVGo. It was great to see what people were doing with Go outside the network related projects we always see. Anthony&rsquo;s talk was great, he was using Go to generate SVG for all sorts of things. One important point that stayed with me about his talk, was about dissecting a complex image into just lines and arcs, this allowed you to then build up a replica image (using SVGo) using just these primitives. He also spoke about his project with great passion.</p>

<h4 id="gomobile:184802dcbae007fe12d15202c45527c5">Gomobile</h4>

<p>David Crawshaw the creator of gomobile spoke about the challenges of getting Go up and running on mobile platforms. Some of the topics he discussed were Go&rsquo;s calling convention and threading (goroutines, OS threads and CPUs).</p>

<p><a href="https://github.com/golang/mobile">gombile on github</a></p>

<h4 id="a-tour-of-the-bleve:184802dcbae007fe12d15202c45527c5">A Tour of the Bleve</h4>

<p>Marty Schoch the creator of Bleve gave an excellent talk on the open-source full-text search library for Go. Marty presented great code examples along side his talk, which really helped clarify the points he was trying to get across. He also spoke about how members of the community have contributed to the project. This was probably my favorite talk, and I also learned how to pronounce Bleve :)</p>

<p><a href="http://www.blevesearch.com/">bleve homepage</a></p>

<h4 id="simplicity-is-complicated:184802dcbae007fe12d15202c45527c5">Simplicity is Complicated</h4>

<p>A talk given by the excellent Rob Pike co-creator of Go. He stated that even though Go is a very simple language, a lot of the complexity is hidden behind the scenes. He talked about how simplicity and complexity are part of the design and finding the right balance is a challenging task. This was good talk, and when listening I thought about the <em>go</em> keyword.</p>

<pre><code class="language-go">go someFunction()
</code></pre>

<p>This in Go is a simple way to get concurrency into your program and all the complexity of scheduling is hidden behind the scenes.</p>

<p>There were also a series of ten minute lightning talks, one of these was given by Brad Fitz about http2 in Go. http2 will be available in go 1.6.</p>

<p>Full list of dotGo videos can be found <a href="http://www.thedotpost.com/conference/dotgo-2015">here</a>.</p>

<p>Overall I really enjoyed my time at dotGo, and Paris is an amazing and buzzing city. I will never forget standing on my Hotel balcony and listening to a trumpeter playing for tips, with the noise of the city in the background.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/10/tmux-cross-platform/">
        tmux Cross Platform Config.
      </a>
    </h1>

    <span class="post-date">Oct 20, 2015</span>

    


    <p>If like me you use tmux on both Linux and OS X, then managing your tmux configuration can be a pain. The problem is there is configuration that is specific to either OS, such as copy and paste behavior. This blog post will show you how to manage your tmux configuration across platforms in a better way.</p>

<p>The first thing you want to do is create a dot file for each platform, so for Linux create <em>.tmux-linux.conf</em> and for OS X create <em>.tmux-osx.conf</em>. Create and place these files in the same location as your <em>.tmux.conf</em> file (most likely your home directory).</p>

<p>Now move any OS specific settings out of <em>.tmux.conf</em> into <em>.tmux-osx.conf</em> and <em>.tmux-linux.conf</em> respectively.</p>

<p>In your <em>.tmux.conf</em> file add the line:</p>

<pre><code class="language-bash">if-shell &quot;uname | grep -q Darwin&quot; 'source-file ~/.tmux-osx.conf' \
'source-file ~/.tmux-linux.conf'
</code></pre>

<p>Basically, when tmux reads in it&rsquo;s configuration, if the OS is &lsquo;Darwin&rsquo; (OS X) then it will read <em>.tmux-osx.conf</em> else it will read in <em>.tmux-linux.conf</em>.</p>

<p>Note: the above code snippet assumes that the three *.conf files are placed in your home directory, if they are not change the paths.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/09/go-todo/">
        Things to do before committing Go code
      </a>
    </h1>

    <span class="post-date">Sep 2, 2015</span>

    


    <p>This blog post will list some of the basic things you should really do before committing Go code into your repository.</p>

<p><strong>1)</strong> Run gofmt/goimports</p>

<p><em>gofmt</em> is probably the most popular Go tool amongst gophers. The job of <em>gofmt</em> is to
format Go packages, your code will be formatted to be consistent across your code base. For example if we have the following <em>if</em> statement:</p>

<pre><code class="language-go">if x == 42 { fmt.Println(&quot;The answer to everything&quot;) }
</code></pre>

<p>Then running <em>gofmt</em> on this will format the code to:</p>

<pre><code class="language-go">if x == 42 { 
    fmt.Println(&quot;The answer to everything&quot;) 
}
</code></pre>

<p><em>goimports</em> is a tool that does exactly what <em>gofmt</em> does, but takes it a step further and adds/removes packages. For example if you had the following code:</p>

<pre><code class="language-go">package main

import (
    &quot;log&quot;
)

func main() {
    fmt.Println(&quot;Hello&quot;)
}
</code></pre>

<p>As you can see from this code, package &lsquo;log&rsquo; is not used anywhere and package &lsquo;fmt&rsquo; has not been imported. Running <em>goimports</em> on this code transforms it to:</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

func main() {
    fmt.Println(&quot;Hello&quot;)
}
</code></pre>

<p>Running either of these tools on your code is a must, its great to see a code base using common idioms and a consistent format/style. And to me, it&rsquo;s one of main things that makes Go code bases so more approachable than code bases in other languages.</p>

<p><strong>2)</strong> Run golint</p>

<p><em>golint</em> will lint your source code and make suggestions concerning coding style.</p>

<p>see <a href="https://github.com/golang/lint">golint on github</a>.</p>

<p><strong>3)</strong> Run go vet</p>

<p>Go <em>vet</em> is another important tool, it&rsquo;s perfectly summed up by it&rsquo;s documentation:</p>

<p><em>&ldquo;Vet examines Go source code and reports suspicious constructs, such as Printf calls whose arguments do not align with the format string. Vet uses heuristics that do not guarantee all reports are genuine problems, but it can find errors not caught by the compilers.&rdquo;</em></p>

<p>If we run go <em>vet</em> on the following code:</p>

<pre><code class="language-go">fmt.Printf(&quot;%s&quot;, 42)
</code></pre>

<p>We would get the following error:</p>

<pre><code>test.go:6: arg 42 for printf verb %s of wrong type: int
exit status 1
</code></pre>

<p>Go <em>vet</em> differs from <em>golint</em>, go <em>vet</em> is concerned with correctness and <em>golint</em> is concerned with coding style.</p>

<p>see <a href="https://godoc.org/golang.org/x/tools/cmd/vet">here</a> for more information on <em>vet</em>.</p>

<p><strong>4)</strong> Run build/install/run with -race flag:</p>

<p>There is a fully integrated race detector in the go tool chain. The race detector contains complex race detection and deadlock algorithms, to help you hunt down those hard to find concurrency related bugs.</p>

<p>To enable the race detector in your code, add the -race flag on the command line:</p>

<pre><code>$ go test -race mypkg    // test the package
$ go run -race mysrc.go  // compile and run the program
$ go build -race mycmd   // build the command
$ go install -race mypkg // install the package
</code></pre>

<p>Note: Your code will run slower when you enable this flag, as the race detector is busy doing its thing :)</p>

<p><strong>5)</strong> Run a dependency management tool</p>

<p>It&rsquo;s very likely that your project will make use of 3rd party libraries. If you need to capture there versions, run a dependency management tool. Below is a list of some popular ones:</p>

<ul>
<li><a href="https://github.com/constabulary/gb">gb on github</a></li>
<li><a href="https://github.com/tools/godep">godeps on github</a></li>
<li><a href="https://github.com/Masterminds/glide">glide on github</a></li>
</ul>

<p>I have no real experience with the above tools but instead use the go 1.5 vendor experiment feature to capture dependencies.</p>

<p>I hope this lists helps you in some way in managing your Go projects. Remember, this is just a basic list, Go has numerous tools that you probably run which are essential to you or your project. The ones listed above are ones which I believe are the basics.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/08/golang-uk-conf-2015/">
        Golang UK Conference 2015
      </a>
    </h1>

    <span class="post-date">Aug 25, 2015</span>

    


    

<p><img src="https://i.imgur.com/LJfFYSS.png" alt="British Gopher" /></p>

<p>On Friday the 21st of August I attended the <a href="http://www.golanguk.com/">Golang UK conference 2015</a> held at
the amazing Brewery in London. This post is a short write up of my time at the
conference.</p>

<p>This was my first ever conference so apart from the talks, I did not know what
else to expect. Overall though, I found the conference was excellent and I met
a wide range of interesting people.</p>

<h5 id="turnout:95f078b9982a0bb9d2c4f8afc300946a">Turnout</h5>

<p>The turnout was quite big with over 250 delegates from all over the world.</p>

<h5 id="go-usage:95f078b9982a0bb9d2c4f8afc300946a">Go usage</h5>

<p>From the people I met no one was really using Go in a big way, but had an
API or a small server component written in Go. However, everyone was expecting
to increase there Go usage through out the coming year.</p>

<h5 id="talks:95f078b9982a0bb9d2c4f8afc300946a">Talks</h5>

<p>The conference consisted of 2 tracks, a main track and a side track. The talks I
went to:</p>

<ul>
<li>Opening Keynote</li>
<li>Crossing the Language Chasm</li>
<li>Building API&rsquo;s</li>
<li>Complex Concurrency Patterns in Go</li>
<li>Code Analysis</li>
<li>Understanding Memory Allocation</li>
<li>Whispered Secrets</li>
<li>The Go Community</li>
</ul>

<p>Out of all the talks, the best one was Code Analysis presented by Francesc Campoy.</p>

<h5 id="food:95f078b9982a0bb9d2c4f8afc300946a">Food :)</h5>

<p>The food served at the conference was absoutetly amazing. Many of the delgates
said that it was best food of any conference they had been to.</p>

<p>Fin.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/08/gofmt-rewrite-rules/">
        Gofmt and Rewrite Rules
      </a>
    </h1>

    <span class="post-date">Aug 4, 2015</span>

    


    <p>One thing I absolutely love about Go is its tooling support. Whenever I use the
numerous tools I always discover something new. In this short post I will be
showing off gofmt&rsquo;s -r flag, this flag allows you to apply a rewrite rule to your
source before formatting.</p>

<p>A rewrite rule is a string in the following format:</p>

<pre><code>pattern -&gt; replacement
</code></pre>

<p>Both pattern and replacement must be valid Go expressions (more on this later), lets
apply a simple rewrite to the following code:</p>

<pre><code>// test1.go
package main

import (
    &quot;fmt&quot;
)

func main() {
    foo := &quot;Hello World&quot;

    fmt.Println(foo)
}
</code></pre>

<p>The following rewrite rule changes the variable name from &lsquo;foo&rsquo; to &lsquo;bar&rsquo;:</p>

<pre><code>$ gofmt -r='foo -&gt; bar' test1.go
</code></pre>

<p>Output:</p>

<pre><code>// test1.go
package main

import (
    &quot;fmt&quot;
)

func main() {
    bar := &quot;Hello World&quot;

    fmt.Println(bar)
}
</code></pre>

<p>We will now apply a more powerful rule to the below code:</p>

<pre><code>// test2.go
package main

func main() {
    vals := make([]int, 0)

    vals = append(vals, 15)
    vals = append(vals, 17)
    vals = append(vals, 23)

    slice := vals[1:len(vals)]

    _ = slice
}
</code></pre>

<p>The line:</p>

<pre><code>slice := vals[1:len(vals)]
</code></pre>

<p>Is not very idiomatic Go so lets change this:</p>

<pre><code>$ gofmt -r='a[b:len(a)] -&gt; a[b:]' test2.go
</code></pre>

<p>Output:</p>

<pre><code>// test2.go
package main

func main() {
    vals := make([]int, 0)

    vals = append(vals, 15)
    vals = append(vals, 17)
    vals = append(vals, 23)

    slice := vals[1:]

    _ = slice
}
</code></pre>

<p>As you can see the code was correctly transformed. Notice how the rule used the
characters &lsquo;a&rsquo; and &lsquo;b&rsquo;. If your rule uses single-character lowercase identifiers,
then these will serve as wild-cards matching arbitrary sub-expressions; these
expressions will be substituted for the same identifiers in the replacement. So
the rule:</p>

<pre><code>-r='a[b:len(a)] -&gt; a[b:]'
</code></pre>

<p>Would match:</p>

<pre><code>x := vals[1:len(vals)] // vals[1:]
y := nums[5:len(nums)] // nums[5:]
</code></pre>

<p>Were on the first match:</p>

<p>&lsquo;a&rsquo; would be substituted for &lsquo;val&rsquo; <br/>
&lsquo;b&rsquo; would be substituted for &lsquo;1&rsquo; <br/></p>

<p>And on the second match:</p>

<p>&lsquo;a&rsquo; would be substituted for &lsquo;nums&rsquo; <br/>
&lsquo;b&rsquo; would be substituted for &lsquo;5&rsquo; <br/></p>

<p>An important thing to remember when using the -r flag is that the resulting
transformation must be a syntactically valid declaration list, statement list,
or expression. So the following rule:</p>

<pre><code>-r='a[b:len(a)] -&gt; a[const]'
</code></pre>

<p>Would be syntactically incorrect (const is a reserved keyword), and you would get
the error:</p>

<pre><code>parsing replacement a[const] at 1:4: expected operand, found 'const' 
</code></pre>

<p>If you would like to learn more about rewrite rules then run:</p>

<pre><code>$ godoc gofmt
</code></pre>

<p><strong>Note</strong>: godoc gofmt reports the following at the end:</p>

<pre><code>BUGS

The implementation of -r is a bit slow.
</code></pre>

<p>:)</p>

<p><strong>Note</strong>: I am using Go version 1.4.2</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/07/go-string-concat/">
        Go and String Concatenation
      </a>
    </h1>

    <span class="post-date">Jul 26, 2015</span>

    


    

<p>When writing Go code you should try to stay away from concatenating strings using the &lsquo;+&rsquo; and &lsquo;+=&rdquo; operators.</p>

<p>Strings in Go, like many other languages (Java, C#, etc&hellip;) are immutable, this means after a string has been created it is impossible to change. Here is what the <a href="https://golang.org/ref/spec#String_types">Go Programming Language Specification</a> has to say about the string type:</p>

<p><em>&ldquo;A string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is string.&rdquo;</em></p>

<p>Lets look at an example:</p>

<pre><code>var town string = &quot;Spring&quot;
town += &quot;field&quot;
</code></pre>

<p>When you write the above code the compiler actually creates a new sequence of bytes, and assigns it to the variable &lsquo;town&rsquo;. The string &ldquo;Spring&rdquo; is then eligible for garbage collection. Here is what the heap would look like, after the above code was run:</p>

<pre><code>           &quot;Spring&quot;

town ----&gt; &quot;Springfield&quot;
</code></pre>

<p>Now if we concatenate the string &lsquo;town&rsquo; with the another string:</p>

<pre><code>town = &quot;742 Evergreen Terrace &quot; + town
</code></pre>

<p>The heap would look like this:</p>

<pre><code>           &quot;Spring&quot;

           &quot;Springfield&quot;

town ----&gt; &quot;742 Evergreen Terrace Springfield&quot;
</code></pre>

<p>If you concatenate a lot of strings using &lsquo;+&rsquo; and &lsquo;+=&rsquo; you will be generating a lot of garbage. This will make the garbage collector work harder as all those potential dead strings will need to be analyzed and freed.</p>

<p>There are two ways to concatenate string more efficiently:</p>

<h5 id="1-strings-join:09d97f42a93e7b11514ce16c8075547b">1. strings.Join()</h5>

<pre><code>town := strings.Join([]string{&quot;Spring&quot;, &quot;field&quot;}, &quot;&quot;))
</code></pre>

<h5 id="2-bytes-buffer:09d97f42a93e7b11514ce16c8075547b">2. bytes.Buffer</h5>

<pre><code>func concat(vals ...string) string {
    var buffer bytes.Buffer
    for _, s := range vals {
        buffer.WriteString(s)
    }
    return buffer.String()
}

func main() {
    town := concat(&quot;Spring&quot;, &quot;field&quot;)

    names := []string{&quot;Homer&quot;, &quot;Moe&quot;, &quot;Barney&quot;, &quot;Carl&quot;, &quot;Lenny&quot;}

    friends := concat(names...)
    ...
}
</code></pre>

<p>You can use either, I prefer using the &lsquo;concat&rsquo; method as it&rsquo;s easier to read.</p>

<p>These two methods are much more efficient as behind the scenes they allocate a variable size buffer of bytes. Which can be modified over and over again with out leaving behind a lot of unused strings.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/07/calling-c-from-go/">
        Calling C from Go
      </a>
    </h1>

    <span class="post-date">Jul 25, 2015</span>

    


    

<p>This post will show you the basics of how to call C code from a Go package.</p>

<p>Lets get started with an example:</p>

<p>Create a header file &ldquo;add.h&rdquo; with a function prototype:</p>

<pre><code>#ifndef _ADD_H_
#define _ADD_H_
int add(int, int);
#endif
</code></pre>

<p>Create the source file &ldquo;add.c&rdquo; containing the definition for add:</p>

<pre><code>#include &quot;add.h&quot;

int add(int a, int b) 
{
   return a + b;
}
</code></pre>

<p>Create a Go package &ldquo;main.go&rdquo;:</p>

<pre><code>package main

// #include &quot;add.c&quot;
import &quot;C&quot;

import (
    &quot;fmt&quot;
)

func main() {
    r := C.add(40, 2)
    fmt.Println(&quot;result = &quot;, r)
}
</code></pre>

<p>Ouptut:</p>

<pre><code>$ go build main.go
$ ./main
result = 42
</code></pre>

<p>Notice the comment above the import &ldquo;C&rdquo; statement we include add.c not add.h.</p>

<p>If import &ldquo;C&rdquo; is immediately preceded by comments, then those comments become apart of the compilation process. If there are any spaces between the comments, then those are seen as normal go comments, for example:</p>

<pre><code>// #include &lt;math.h&gt;

// #include &lt;stdio.h&gt;
// #include &lt;errno.h&gt;
import &quot;C&quot;
</code></pre>

<p>The header files stdio.h and errno.h are included as part of the compilation process, math.h is <strong>not</strong>.</p>

<h2 id="inline-c:f1759daed9e47388fe7eae5373f5e76d">Inline C</h2>

<p>You can also write C code directly in the comments, here is an example:</p>

<pre><code>package main

/*
int fortytwo()
{
    return 42;
}
*/
import &quot;C&quot;

import (
    &quot;fmt&quot;
)

func main() {
    fmt.Println(C.fortytwo)     // address
    fmt.Println(C.fortytwo())   // invocation
}
</code></pre>

<p>Output:</p>

<pre><code>$ go build inline.go
$ ./inline
0x40014a0
42
</code></pre>

<h2 id="accessing-c-structs:f1759daed9e47388fe7eae5373f5e76d">Accessing C structs</h2>

<p>Assume we have the below C struct defined in a .h or .c file:</p>

<pre><code>struct point {
    int x;
    int y;
};
</code></pre>

<p>In order to access this from a Go package, you simple prefix the type name &ldquo;point&rdquo; with &ldquo;C.struct_&rdquo;:</p>

<pre><code>func main() {
    p := C.struct_point{}
    p.x = 99
    p.y = 42
    fmt.Printf(&quot;type:   %T\n&quot;, p)
    fmt.Printf(&quot;struct: %+v\n&quot;, p)
}
</code></pre>

<p>Output:</p>

<pre><code>$ go build cstruct.go
$ ./cstruct
type:   main._Ctype_struct_point
struct: {x:99 y:42}
</code></pre>

<h2 id="controlling-the-behaviour-of-the-c-compiler:f1759daed9e47388fe7eae5373f5e76d">Controlling the behaviour of the C compiler</h2>

<p>You can pass flags to the C compiler to control its behaviour. This is done by defining a CFLAGS with a pseudo #cgo directive in the comments. In the example below, the -H flag will be passed to the C compiler (clang in my case) when it&rsquo;s invoked. The -H flag tells clang to show the header includes and nesting depth.</p>

<pre><code>package main

// #cgo CFLAGS: -H
// #include &quot;add.c&quot;
import &quot;C&quot;

import (
    &quot;fmt&quot;
)

func main() {
    r := C.add(40, 2)
    fmt.Println(&quot;result = &quot;, r)
}
</code></pre>

<p>Ouptut:</p>

<pre><code>$ go build main.go
!! this output is from clang writing to stdout because we passed the -H flag !!
. ./add.c
.. ./add.h
. /usr/include/errno.h
.. /usr/include/sys/errno.h
... /usr/include/sys/cdefs.h
.... /usr/include/sys/_symbol_aliasing.h
.... /usr/include/sys/_posix_availability.h
...

$ ./main
result = 42
</code></pre>

<h2 id="peeking-behind-the-scenes:f1759daed9e47388fe7eae5373f5e76d">Peeking behind the scenes</h2>

<p>What is happening when we build a Go package that includes an import &ldquo;C&rdquo; statement.</p>

<p>Firstly import &ldquo;C&rdquo; is a pseudo-package it is not listed in the standard library. When the go compiler sees the pseudo-package import &ldquo;C&rdquo; it runs the <strong>cgo</strong> command, this generates all the supporting infrastructure. It transforms main.go outputting some .h and .c files, these are then passed to clang to compile.</p>

<p><strong>Note:</strong> the cgo command actually invokes the gcc compiler, however on my machine gcc is an alias for clang, so it&rsquo;s clang that is doing the compiling.</p>

<p>The output from the C compiler is an object file named _cgo_.o, which contains the compiled C code. This object code (_cgo_.o) is then linked into the rest of the go binary.</p>

<p>Lets runs the cgo command directly to get a better understanding:</p>

<pre><code>$ go tool cgo main.go
</code></pre>

<p>This command will output a directory called _obj:</p>

<pre><code>$ ls _obj/  

_cgo_.o
_cgo_defun.c
_cgo_export.c
_cgo_export.h
_cgo_flags
_cgo_gotypes.go
_cgo_main.c
main.cgo1.go
main.cgo2.c
</code></pre>

<p>As stated _cgo_.o contains the compiled C code, one interesting file to browse is main.cgo2.c:</p>

<pre><code>$ cat main.cgo2.c

#line 10 &quot;/go/src/samples/main.go&quot;

 #include &quot;add.c&quot;

// Usual nonsense: if x and y are not equal, the type will be invalid
// (have a negative array count) and an inscrutable error will come
// out of the compiler and hopefully mention &quot;name&quot;.
#define __cgo_compile_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];

// Check at compile time that the sizes we use match our expectations.
#define __cgo_size_assert(t, n) __cgo_compile_assert_eq(sizeof(t), n, _cgo_sizeof_##t##_is_not_##n)

__cgo_size_assert(char, 1)
__cgo_size_assert(short, 2)
__cgo_size_assert(int, 4)
typedef long long __cgo_long_long;
__cgo_size_assert(__cgo_long_long, 8)
__cgo_size_assert(float, 4)
__cgo_size_assert(double, 8)

extern char* _cgo_topofstack(void);

#include &lt;errno.h&gt;
#include &lt;string.h&gt;

void
_cgo_7474d4d504ba_Cfunc_add(void *v)
{
    struct {
        int p0;
        int p1;
        int r;
        char __pad12[4];
    } __attribute__((__packed__)) *a = v;
    char *stktop = _cgo_topofstack();
    __typeof__(a-&gt;r) r = add(a-&gt;p0, a-&gt;p1);
    a = (void*)((char*)a + (_cgo_topofstack() - stktop));
    a-&gt;r = r;
}
</code></pre>

<p>Take a while to browse the other files, they are quite interesting.</p>

<p>I hope you enjoyed this post.</p>

<p><strong>Note:</strong> I am on OSX 10.10.4 64 bit using go version 1.4.2 and clang version 602.0.53.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://fallthrough.io/2015/07/first/">
        First Post
      </a>
    </h1>

    <span class="post-date">Jul 25, 2015</span>

    


    <p>This is my blog. There are many like it, but this one is mine.</p>

  </div>
  
  
  
  
</div>


  </body>
</html>
